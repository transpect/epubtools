<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:tr="http://transpect.io" 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:opf="http://www.idpf.org/2007/opf" 
  xmlns:epub="http://www.idpf.org/2007/ops"
  xmlns:ncx="http://www.daisy.org/z3986/2005/ncx/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:svg="http://www.w3.org/2000/svg" 
  xmlns:xlink="http://www.w3.org/1999/xlink" 
  xmlns:dtb="http://www.daisy.org/z3986/2005/dtb/"
  xmlns:smil="http://www.w3.org/ns/SMIL"
  xmlns:mml="http://www.w3.org/1998/Math/MathML"
  xmlns="http://www.w3.org/1999/xhtml"
  version="2.0"
  exclude-result-prefixes="html opf xs ncx tr smil dc epub svg dtb mml xlink">

  <!-- Standalone Saxon invocation:
    First invoke an XProc-based conversion with debugging enabled. 
    Then, from the project directory that contains the project’s xmlcatalog/catalog.xml:
    saxon -xsl:epubtools/modules/html-splitter/xsl/html-splitter.xsl \
          -s:any.xml \
          collection-uri=file:/$(cygpath.exe -ma ../path/to/debug-dir/epubtools/html-splitter/base/splitter-input.catalog.xml) \
          -o:x.xml \
          debug=yes \
          debug-dir-uri=file:/$(cygpath.exe -ma debug) \
          -it:main
    Debugging the Saxon invocation is optional.
    any.xml means that the source file given in splitter-input.catalog.xml has precedence and you can supply any XML file as source.
    Instead of using cygpath, you can use readlink -f on GNU systems, or you can compute URIs yourself. -->

	<!-- create references between smil and html chunks -->
	<xsl:include href="media-overlay.xsl"/>

  <xsl:output method="text" />

  <xsl:output name="debug" method="xml" encoding="UTF-8" doctype-public="-//W3C//DTD XHTML 1.1//EN"
    doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" indent="yes"/>
  <!-- Actual doctype (if any) will be set by the p:store serialization options in XProc -->  
  <xsl:output name="export" method="xhtml" encoding="UTF-8" doctype-public="-//W3C//DTD XHTML 1.1//EN"
    doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" indent="no"/>

  <xsl:output name="xml" method="xml" encoding="UTF-8" indent="yes"/>

  <xsl:output name="text" method="text" encoding="UTF-8"/>

  <!-- Sample invocation:
       See ../xpl/html-splitter.xpl 

     Calabash seems to suppress some XSLT errors, for instance when a stylesheet is looping.
     Therefore it might be necessary to run saxon from the command line. 
     See html-splitter.xpl for an example.
       -->

  <xsl:param name="collection-uri" as="xs:string?" select="()">
    <!-- Pass the URI of epubtools/html-splitter/…/splitter-input.catalog.xml that whas stored during
      debugging for standalone invocation with Saxon.
    Note that you still need to provide an input document for XSLT invocation. It can be the HTML source,
    but if an HTML source document is listed in $collection-uri, this will have precedence. Then you 
    can supply a bogus source document, for example, this XSLT file or the collection catalog file. --> 
  </xsl:param>
  <xsl:param name="datadir" select="resolve-uri('.', base-uri(/*))" as="xs:string"/>
  <xsl:param name="heading-conf-uri" as="xs:string?"/>
  <xsl:param name="meta-uri" as="xs:string?"/>
  <!-- which package format we want to create later? (values: 'epub' or 'mobi'; empty string: 'epub')-->
  <xsl:param name="final-pub-type" select="''" as="xs:string"/>
  <!-- indent: true|false|selective
       true and false are being dealt with by XPRoc’s p:store serialization options.
       If indent="selective", p:store will store non-indented, and the indent before paragraphs etc.
       must be generated by this stylesheet, in the mode remove-surrounding-text.-->
  <xsl:param name="indent" select="'true'" as="xs:string"/>
  <xsl:param name="html-subdir-name" select="''" as="xs:string"/>
  <xsl:variable name="html-prefix" select="if (normalize-space($html-subdir-name)) then concat($html-subdir-name, '/') else ''"/>
  <!-- debug params -->
  <xsl:param name="debug" select="'no'"/>
  <xsl:param name="debug-dir-uri" select="'debug'"/>

  <xsl:param name="pull-up-epub-type-to-body" select="'false'" as="xs:string"/>

  
  <xsl:variable name="common-dir-elimination-regex" as="xs:string"
    select="replace($datadir, '/+', '/+')"/>
  <xsl:variable name="orig-filename" select="replace(base-uri(/*), '^.*/', '')"/>
  <xsl:variable name="raw-smil-filename" select="replace(base-uri(/*), '[.]\w+$', '.raw.smil')"/>
  <xsl:variable name="epub-config" select="collection($collection-uri)/epub-config" as="element(epub-config)"/>
  <!-- If heading conf is submitted in a separate file, it will have precedence. It may be submitted as /epub-config/hierarchy -->
  <xsl:variable name="heading-conf"
    select="(collection($collection-uri)/hierarchy, collection($collection-uri)/epub-config/hierarchy)[1]" as="element(hierarchy)"/>
  <xsl:variable name="metadata" select="$epub-config/metadata" as="element(metadata)"/>
  <xsl:variable name="epub-types-for-pulling-to-body" select="if ($epub-config/types/@pull-up-types[normalize-space()]) 
                                                              then tokenize($epub-config/types/@pull-up-types, '\s+') 
                                                              else ('frontmatter', 'bodymatter', 'backmatter')" as="xs:string+">
    <!-- you can add custom types to be pulles up in on the types element of the epub-config file -->
  </xsl:variable>

  <!-- CATCH-ALL IDENTITY TEMPLATE -->
  <xsl:template match="node()|@*" mode="#all" priority="-0.9">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:apply-templates select="*|text()" mode="#current"/>
    </xsl:copy>
  </xsl:template>


  <!-- KEYS and GLOBAL VARIABLES -->
  <xsl:variable name="root" select="(collection($collection-uri)[html:html], /)[1]" as="document-node(element(html:html))"/>

  <!-- input file name / URL without path and extension: --> 
  <xsl:param name="basename" as="xs:string" select="replace(base-uri(/*), '^.+/', '')"/>
  <xsl:variable name="splatter-debug-dir-uri" as="xs:string"
    select="concat($debug-dir-uri, '/epubtools/html-splitter/', $basename)"/>
  

  <xsl:key name="by-signature" match="*" use="tr:signature-from-doc(.)"/>
  <xsl:key name="by-genid" match="*" use="generate-id()"/>
  <xsl:key name="by-tr-genid" match="*" use="@tr-generated-id"/>
  <xsl:key name="by-id" match="*[@id]" use="@id"/>
  <xsl:key name="by-any-id-available" match="*[@id | @tr-generated-id]" use="@id, @tr-generated-id"/>
  <xsl:key name="chunk-by-id" match="html:chunk" use=".//@id[not(. = '')]"/>

  <xsl:variable name="candidates" select="key('by-signature', for $h in $heading-conf/* return tr:signature-from-conf($h), $root)"
    as="element(*)*"/>
  <xsl:variable name="candidate-ids" select="for $n in $candidates return generate-id($n)" as="xs:string*"/>
  <xsl:variable name="removable-ids"
    select="for $r in $candidates[tr:signature-from-doc(.) = (for $h in $heading-conf/*[@remove eq 'yes'] 
                                               return tr:signature-from-conf($h))] return generate-id($r)"
    as="xs:string*"/>


  <!-- PROCESSING PIPELINE using global variables which hold transformed trees: -->
  <xsl:variable name="semiflatten" as="document-node(element(html:html))">
    <xsl:document>
      <xsl:apply-templates select="$root" mode="semiflatten"/>  
    </xsl:document>
  </xsl:variable>
  <xsl:variable name="fullflatten" as="element(html:html)">
    <xsl:apply-templates select="$semiflatten" mode="fullflatten"/>
  </xsl:variable>
  <xsl:variable name="group-starting-with-split-candidates" as="element(html:html)">
    <xsl:apply-templates select="$semiflatten" mode="group-starting-with-split-candidates"/>
  </xsl:variable>
  <xsl:variable name="respect-hierarchy-among-conditional-split-candidates" as="element(html:html)">
    <xsl:apply-templates select="$group-starting-with-split-candidates"
      mode="respect-hierarchy-among-conditional-split-candidates"/>
  </xsl:variable>
  <xsl:variable name="partially-ungroup-to-final-split-points" as="element(html:html)">
    <xsl:apply-templates select="$respect-hierarchy-among-conditional-split-candidates"
      mode="partially-ungroup-to-final-split-points"/>
  </xsl:variable>
  <xsl:variable name="output-file-names" as="document-node(element(html:html))">
    <xsl:document>
      <xsl:apply-templates select="$partially-ungroup-to-final-split-points" mode="output-file-names"/>
    </xsl:document>
  </xsl:variable>
  <!-- $chunks has to be a document node because it will serve as 3rd argument to xsl:key() -->
  <xsl:variable name="chunks" as="document-node(element(html:chunks))">
    <xsl:document>
      <xsl:sequence 
        select="tr:chunks($output-file-names/html:html/html:body//@tr-generated-id
                          [empty(ancestor::html:content)]
                          [
                            (: https://redmine.le-tex.de/issues/6590 also 6624 :)
                            not(./ancestor-or-self::*/@tr-generated-id = ../ancestor::*/(@tr-dont-split-at-genid (:| @tr-generated-id:)))
                          ])"/>
    </xsl:document>
  </xsl:variable>
  <xsl:variable name="raw-ncx" as="document-node(element(ncx:navMap))">
    <xsl:document>
      <xsl:apply-templates select="$fullflatten" mode="raw-ncx"/>
    </xsl:document>
  </xsl:variable>

  <xsl:variable name="epub3-landmark-types" as="xs:string+" select="('acknowledgments',
                                                                     'backmatter', 
                                                                     'bibliography', 
                                                                     'bodymatter', 
                                                                     'copyright-page',
                                                                     'cover', 
                                                                     'frontmatter', 
                                                                     'glossary', 
                                                                     'index', 
                                                                     'loi', 
                                                                     'lot', 
                                                                     'preface', 
                                                                     'titlepage', 
                                                                     'toc' 
                                                                     )"/>
  <xsl:variable name="landmark-types" as="xs:string+" 
    select="if (normalize-space($epub-config/types/type[@name = 'landmarks']/@types))
            then tokenize($epub-config/types/type[@name = 'landmarks']/@types, '\s+')
            else $epub3-landmark-types"/>


  <xsl:variable name="epub3-publisher-roles" as="xs:string+"
     select="('doc-abstract', 'doc-acknowledgments', 'doc-afterword', 'doc-appendix', 'doc-backlink', 'doc-biblioentry', 'doc-bibliography', 
              'doc-biblioref', 'doc-chapter', 'doc-colophon', 'doc-conclusion', 'doc-cover', 'doc-credit', 'doc-credits', 'doc-dedication', 
              'doc-endnote', 'doc-endnotes', 'doc-epigraph', 'doc-epilogue', 'doc-errata', 'doc-example', 'doc-footnote', 'doc-foreword', 'doc-glossary', 
              'doc-glossref', 'doc-index', 'doc-introduction', 'doc-noteref', 'doc-notice', 'doc-pagebreak', 'doc-pagelist', 'doc-part', 'doc-preface', 
              'doc-prologue', 'doc-pullquote', 'doc-qna', 'doc-subtitle', 'doc-tip', 'doc-toc')"/>

  <xsl:template name="main">
    <xsl:if test="not($heading-conf)">
      <xsl:message terminate="yes">Cannot access the heading configuration XML file. A URI to a proper heading conf must be
        given using heading-conf-uri=... Please consider that relative paths are relative to the XSL stylesheet. When invoking
        this via XProc, the configuration may be given as the second document on this step’s source port. </xsl:message>
    </xsl:if>

    <xsl:if test="$debug eq 'yes'">
      <xsl:result-document href="{$splatter-debug-dir-uri}/03.semiflatten.xhtml" format="debug">
        <debug><xsl:sequence select="$semiflatten"/></debug>
      </xsl:result-document>
      <xsl:result-document href="{$splatter-debug-dir-uri}/03a.fullflatten.xhtml" format="debug">
        <debug><xsl:sequence select="$fullflatten"/></debug>
      </xsl:result-document>
      <xsl:result-document href="{$splatter-debug-dir-uri}/04.group-starting-with-split-candidates.xhtml" format="debug">
        <debug><xsl:sequence select="$group-starting-with-split-candidates"/></debug>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/05.respect-hierarchy-among-conditional-split-candidates.xhtml"
        format="debug">
        <debug><xsl:sequence select="$respect-hierarchy-among-conditional-split-candidates"/></debug>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/06.partially-ungroup-to-final-split-points.xhtml" format="debug">
        <debug><xsl:sequence select="$partially-ungroup-to-final-split-points"/></debug>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/07.output-file-names.xhtml" format="debug">
        <debug><xsl:sequence select="$output-file-names"/></debug>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/08.chunks.xhtml" format="debug">
        <xsl:apply-templates select="$chunks"/>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/10.raw-ncx.xml" format="debug">
        <xsl:apply-templates select="$raw-ncx"/>
      </xsl:result-document>
    </xsl:if>

    <!-- remove other content (i.e. mobi when final publication format is epub) -->
    <xsl:variable name="strip-other-content">
      <xsl:apply-templates select="$root" mode="remove-other-pub-type-content"/>
    </xsl:variable>
    <xsl:variable name="chunks-text"
        select="replace(string-join($chunks/html:chunks/html:chunk/html:html/html:body, ''), '[\s\p{Zs}]+', '&#xa;')" as="xs:string"/>
    <xsl:variable name="orig-text" select="replace($strip-other-content/html:html/html:body, '[\s\p{Zs}]+', '&#xa;')" as="xs:string"/>
    <xsl:if test="$chunks-text ne $orig-text">
      <xsl:message>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Chunked
        text (modulo whitespace) is not identical to original text! Please diff <xsl:value-of select="$splatter-debug-dir-uri"
        />/chunks.txt and <xsl:value-of select="$splatter-debug-dir-uri"/>/orig.txt. This problem may arise when there is
        non-whitespace text on the same level as splitting elements, or when there was text within an element that has been
        removed after splitting unconditionally at said element. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! </xsl:message>
      <!-- Even though these are going to be text files, we have to supply XML documents
          and store them as text in the xpl according to their file extensions.
          Otherwise Calabash will silently break. -->
      <xsl:result-document href="{$splatter-debug-dir-uri}/chunks.txt" format="xml">
        <doc>
          <xsl:value-of select="$chunks-text"/>
        </doc>
      </xsl:result-document>
      <xsl:result-document href="{$splatter-debug-dir-uri}/orig.txt" format="xml" encoding="utf8">
        <doc>
          <xsl:value-of select="$orig-text"/>
        </doc>
      </xsl:result-document>
    </xsl:if>

    <!--<xsl:variable name="landmarks" as="element(*)*"
      select="$chunks/html:chunks/html:chunk//*[@id | @tr-generated-id][tr:contains-token(@epub:type, $landmark-types)]"/>-->

    <xsl:variable name="landmarks" as="element(*)*">
      <xsl:for-each-group select="$chunks/html:chunks/html:chunk//*[@id | @tr-generated-id | .[empty(@id)]/html:a/@id | .[empty(@id)]/html:section[1]/@id]
                                                                   [tr:contains-token(@epub:type, $landmark-types)]"
                          group-by="tokenize(@epub:type, '\s+')[. = $landmark-types]">
        <!-- index, preface, … may occur multiple times. Use only the first item of a kind 
          (also in order to avoid kindlegen warnings). -->
        <!-- modify epub-type to allow selection of correct @heading if several types match. -->
        <xsl:element name="{current-group()[1]/name()}">
          <xsl:copy-of select="current-group()[1]/@*"/>
          <xsl:attribute name="epub:type" select="current-grouping-key()"/>
          <xsl:copy-of select="current-group()[1]/node()"/>
        </xsl:element>
      </xsl:for-each-group>
    </xsl:variable>

    <!-- write page-map.xml -->
    <xsl:if test="($epub-config/@page-map-xml, 'true')[1] ne 'false' and $final-pub-type ne 'EPUB3'">
      <xsl:apply-templates select="$pgl" mode="page-map"/>
    </xsl:if>

    <xsl:variable name="toc-ncx" as="element(ncx:ncx)">
      <xsl:call-template name="ncx">
        <xsl:with-param name="final-chunks" select="$chunks" tunnel="yes"/>
      </xsl:call-template>
    </xsl:variable>
    <!-- write toc NCX for EPUB2
      and EPUB3: http://www.idpf.org/epub/301/spec/epub-publications.html#ncx-superseded
    -->
    <xsl:result-document href="{$datadir}/chunks/toc.ncx" format="xml">
      <xsl:choose>
        <xsl:when test="$indent = 'selective'">
          <xsl:apply-templates select="$toc-ncx" mode="add-selective-indent"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$toc-ncx"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:result-document>

    <!-- write HTML toc nav for EPUB3 (will also be created for EPUB2 etc. but has to be discarded before storing to disk.
      Reason: being able to generate a guide element in the content.opf) -->
    <!-- when *[@epub:type] with value 'toc' is present in content documents, the landmarks nav is created there too -->
    <xsl:if test="not($chunks//*[tr:contains-token(@epub:type, 'toc')])">
      <xsl:variable name="toc-nav">
        <xsl:call-template name="toc-nav">
          <xsl:with-param name="toc-ncx" select="$toc-ncx"/>
          <xsl:with-param name="landmarks" select="$landmarks"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:result-document href="{$datadir}/chunks/nav.xhtml" format="export">
        <xsl:choose>
          <xsl:when test="$indent = 'selective'">
            <xsl:apply-templates select="$toc-nav" mode="add-selective-indent"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="$toc-nav"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:result-document>
    </xsl:if>

    <!-- write chunks -->
    <xsl:for-each select="$chunks/html:chunks/html:chunk">
      <xsl:result-document href="{@file}" format="export">
        <xsl:apply-templates select="html:html" mode="resolve-refs">
          <xsl:with-param name="pos" select="position()" tunnel="yes"/>
          <xsl:with-param name="landmarks" select="$landmarks" tunnel="yes"/>
        </xsl:apply-templates>
      </xsl:result-document>
    </xsl:for-each>
    
    <xsl:if test="doc-available($raw-smil-filename)">
      <xsl:call-template name="smil">
        <xsl:with-param name="smil" select="document($raw-smil-filename)/smil:smil"/>
        <xsl:with-param name="text" select="$chunks"/>
        <xsl:with-param name="datadir" select="$datadir"/>
        <xsl:with-param name="html-subdir-name" select="$html-subdir-name"/>
      </xsl:call-template>
    </xsl:if>

    <xsl:sequence select="$chunks"/>

  </xsl:template>

  <xsl:template match="html:meta[@http-equiv]">
    <xsl:choose>
      <xsl:when test="$final-pub-type eq 'EPUB3' and matches(@content, 'charset=')">
        <xsl:variable name="charset" select="replace(@content, '^.*charset=(.*)$', '$1')"/>
        <meta charset="{$charset}"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:copy>
          <xsl:apply-templates select="@*"/>
        </xsl:copy>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="add-selective-indent page-map" priority="2"
    match="ncx:ncx//* | html:html/* | html:pgl/html:page">
    <xsl:text>&#xa;</xsl:text>
    <xsl:sequence select="string-join(for $i in 0 to count(ancestor::*) return '  ', '')"/>
    <xsl:next-match/>
  </xsl:template>

  <xsl:template match="ncx:*[not(self::ncx:text or self::ncx:content or self::ncx:meta)]" mode="add-selective-indent">
    <xsl:copy>
      <xsl:apply-templates select="@*, node()" mode="#current"/>
      <xsl:text>&#xa;</xsl:text>
      <xsl:sequence select="string-join(for $i in 0 to count(ancestor::*) return '  ', '')"/>
    </xsl:copy>
  </xsl:template>

  <!-- MODE: SEMIFLATTEN
       Dissolve divs which contain more than a single heading (important for later grouping) -->
  <xsl:variable name="tr:dissolvable-for-semiflatten" as="element(*)*"
    select="$root//*[local-name() = ('aside', 'div', 'nav', 'header', 'hgroup', 'section', ('figure')[$tr:subheadings-in-figure],
                ('table', 'tbody', 'tr', 'td', 'th')[$epub-config/@consider-headings-in-tables = 'true'
                                                     or $tr:subheadings-in-table])]"/>

  <xsl:variable name="tr:subheadings-in-table" as="xs:boolean" 
    select="exists(//html:tr[exists(.//*[tr:contains-token(@class, ('TOC_same', 'TOC_sub'))])])"/>

  <xsl:variable name="tr:subheadings-in-figure" as="xs:boolean" 
    select="exists(//html:figure[exists(.//*[tr:contains-token(@class, ('TOC_same', 'TOC_sub'))])])"/>
  
  <xsl:template
    match="*[exists(. intersect $tr:dissolvable-for-semiflatten)][
                         (count(.//* intersect $candidates) gt 1)
                         and not(
                           generate-id(.) = $candidate-ids
                           and $heading-conf/unconditional-split[tr:signature-from-conf(.) = tr:signature-from-doc(current())]  
                         )
                         or exists(.//*[tr:contains-token(@class, ('TOC_same', 'TOC_sub'))])
                       ]"
    mode="semiflatten">
    <xsl:processing-instruction name="origin" select="'A'"/>
    <xsl:apply-templates mode="#current"/>
  </xsl:template>

  <!-- match a no split element (i.e. cover div) before very first split candidate -->
  <xsl:template
    match="*[. is $tr:dissolvable-for-semiflatten[1]]
            [
              count(.//* intersect $candidates) eq 0
              and not(
                generate-id(.) = $candidate-ids
              )
            ]" 
    mode="semiflatten">
    <xsl:copy>
      <xsl:attribute name="origin" select="'B'"/>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="tr-splitting-priority" select="'unconditional'"/>
      <xsl:if test="not(@id)">
        <xsl:attribute name="id" select="generate-id()"/>
        <xsl:attribute name="tr-source-element-without-id-attribute" select="'true'"/>
      </xsl:if>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <xsl:apply-templates select="node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  
  <xsl:template
    match="*[empty(@id)]
            [tr:contains-token(@class, ('TOC_same', 'TOC_sub'))]" 
    mode="semiflatten export-chunk-subtree export-chunk-with-surroundings">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="id" select="generate-id()"/>
      <xsl:attribute name="tr-source-element-without-id-attribute" select="'true'"/>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="*[exists(. intersect $tr:dissolvable-for-semiflatten)][count(.//* intersect $candidates) eq 1]
                        [not(ancestor::*[exists(. intersect $tr:dissolvable-for-semiflatten)][count(.//* intersect $candidates) eq 1])]" mode="semiflatten"
    priority="2">
    <xsl:param name="split-for" as="xs:string?"/>
    <xsl:variable name="contained-candidate" select=".//* intersect $candidates" as="element(*)"/>
    <xsl:copy copy-namespaces="no">
      <xsl:attribute name="origin" select="'C'"/>
      <xsl:copy-of select="@*"/>
      <xsl:attribute name="tr-split-for" select="generate-id($contained-candidate)"/>
      <xsl:apply-templates select="($contained-candidate, .)/@epub:type" mode="#current"/>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <xsl:variable name="dont-split" as="xs:boolean" 
        select="tr:contains-token(string-join((current(), $contained-candidate)/@class, ' '), '_nosplit')"/>
      <xsl:variable name="corresponding-conf-items-for-current" as="element()*"
        select="$heading-conf/*[tr:signature-from-conf(.) = tr:signature-from-doc(current())]"/>
      <xsl:variable name="corresponding-conf-items-for-candidates" as="element()*"
        select="$heading-conf/*[tr:signature-from-conf(.) = tr:signature-from-doc($contained-candidate)]"/>
      <xsl:variable name="corresponding-conf-items"
        select="$corresponding-conf-items-for-current
                union
                $corresponding-conf-items-for-candidates"
        as="element()+"/>
      <xsl:for-each select="$corresponding-conf-items/@max-text-length">
        <xsl:attribute name="tr-max-text-length" select="."/>
      </xsl:for-each>
      <xsl:attribute name="tr-splitting-priority">
        <xsl:choose>
          <!-- unconditional split on a splitting delegate div beats _nosplit on its contained heading -->
          <xsl:when test="tr:contains-token($contained-candidate/@class, '_nosplit')
                          and $corresponding-conf-items-for-current/name() = 'unconditional-split'
                          and not(tr:contains-token(@class, '_nosplit'))">
            <xsl:sequence select="'unconditional'"/>
          </xsl:when>
          <xsl:when test="tr:contains-token(current()/@class, '_nosplit')">
            <xsl:sequence select="'conditional'"/>
          </xsl:when>
          <xsl:when test="$corresponding-conf-items/name() = 'unconditional-split'">
            <xsl:sequence select="'unconditional'"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="'conditional'"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <xsl:if test="$corresponding-conf-items/@linear = 'no'">
        <xsl:attribute name="tr-linear" select="'no'"/>
      </xsl:if>
      <xsl:if test="$corresponding-conf-items/name() = 'heading'">
        <xsl:attribute name="tr-heading-level"
          select="( $corresponding-conf-items[name() = 'heading']/@level,
                   tr:index-of($heading-conf/heading, $corresponding-conf-items[name() = 'heading']) )[1]"
        />
        <!--<xsl:message select="'cci:', $corresponding-conf-items, '$heading-conf', $heading-conf"/>-->
      </xsl:if>
      <xsl:if test="$corresponding-conf-items/name() = 'conditional-split'">
        <xsl:attribute name="tr-heading-level"
          select="( $corresponding-conf-items[name() = 'conditional-split'][1]/@level,
                   100 + tr:index-of($heading-conf/conditional-split, $corresponding-conf-items[name() = 'conditional-split'][1]) )[1]"
        /><!-- 100 is important for a distinction, see below (we could have used other element names, but that’s the way
          we implemented it) -->
        <xsl:if test="$corresponding-conf-items[name() = 'conditional-split'][1]/@nav = 'no'">
          <xsl:attribute name="tr-exclude-from-nav" select="'tr-exclude-from-nav'"/>  
        </xsl:if>
      </xsl:if>
      <xsl:apply-templates mode="#current">
        <xsl:with-param name="split-for" select="($split-for, generate-id())[1]"/>
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>

  <!-- lower priority than previous template. This means that an unconditional-split div
       won't be dealt with in this template if it contains exactly one heading or 
       unconditional-split in its subtree. -->
  <xsl:template match="*[generate-id(.) = $candidate-ids]" mode="semiflatten">
    <xsl:param name="split-for" as="xs:string?"/>
    <xsl:copy copy-namespaces="no">
      <xsl:attribute name="origin" select="'D'"/>
      <xsl:copy-of select="@*"/>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <!-- Just in case that there is no epub:type here but on a dissolved ancestor, we transform the 
        ancestor’s epub:type, too. -->
<!--      <xsl:apply-templates select="ancestor::*[@epub:type][1]/(@epub:type|@role), (@epub:type|@role)" mode="#current"/>-->
      <xsl:apply-templates select="ancestor::*[@epub:type][1]/@epub:type, @epub:type" mode="#current"/>
      <xsl:if test="not(@id)">
        <xsl:attribute name="id" select="generate-id()"/>
        <xsl:attribute name="tr-source-element-without-id-attribute" select="'true'"/>
      </xsl:if>
      <xsl:variable name="conf-item-candidates" as="element(*)+"
        select="$heading-conf/*[tr:signature-from-conf(.) = tr:signature-from-doc(current())]"/>
      <xsl:variable name="corresponding-conf-items" as="element()+">
        <xsl:for-each-group select="$conf-item-candidates" group-by="name()">
          <!-- For each group (there may be three: unconditional-split, conditional-split, and heading) return the first
               item after they've been sortet by hash length. This is the most specific element of each category.
               This approach seems a bit clumsy. -->
          <xsl:variable name="conf-signatures" as="xs:string+">
            <xsl:perform-sort select="for $cg in current-group() return tr:signature-from-conf(.)">
              <xsl:sort select="string-length(.)" order="descending"/>
            </xsl:perform-sort>
          </xsl:variable>
          <xsl:sequence select="current-group()[tr:signature-from-conf(.) = $conf-signatures[1]]"/>
        </xsl:for-each-group>
      </xsl:variable>
      <xsl:if test="$corresponding-conf-items/name() = 'heading'">
        <xsl:attribute name="tr-heading-level"
          select="( $corresponding-conf-items[name() = 'heading']/@level,
                   tr:index-of($heading-conf/heading, $corresponding-conf-items[name() = 'heading']) )[1]"
        />
      </xsl:if>
      <xsl:if test="$corresponding-conf-items/name() = 'conditional-split'">
        <xsl:attribute name="tr-heading-level"
          select="( $corresponding-conf-items[name() = 'conditional-split'][1]/@level,
                   100 + tr:index-of($heading-conf/conditional-split, $corresponding-conf-items[name() = 'conditional-split'][1]) )[1]"/>
        <xsl:if test="$corresponding-conf-items[name() = 'conditional-split'][1]/@nav = 'no'">
          <xsl:attribute name="tr-exclude-from-nav" select="'tr-exclude-from-nav'"/>  
        </xsl:if>
      </xsl:if>
      <!-- While the topmost matching item is selected as corresponding conf item, the max-text-length setting may
        also be attached to a non-winning conf item candidate. For example, if the content contains h2.chapter-level.ref-list,
        the item <heading elt="h2" attr="class" attval="chapter-level" level="4"/> in line 48 might win over 
        <heading elt="h2" attr="class" attval="ref-list" level="2" max-text-length="70000"/> in line 62.
        Still, if the h2 element also has the class 'ref-list', the latter conf item’s max-text-length should be 
        used (unless the former also specifies max-text-length).
      -->
      <xsl:variable name="max-text-length-override" as="attribute(max-text-length)?" 
        select="($corresponding-conf-items/@max-text-length, $conf-item-candidates/@max-text-length)[1]"/>
      <!--<xsl:message select="'RRRRRRRRRRRR ', $max-text-length-override, 
        string-join(for $i in $conf-item-candidates return tr:signature-from-conf($i), '&#xa;  ')"/>-->
      <xsl:if test="exists($max-text-length-override)">
        <xsl:attribute name="tr-max-text-length" select="string($max-text-length-override)"/>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="$split-for">
          <xsl:attribute name="tr-split-delegation-to" select="$split-for"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:attribute name="tr-splitting-priority"
            select="if ($corresponding-conf-items/name() = 'unconditional-split' and not(tr:contains-token(current()/@class, '_nosplit'))) 
                    then 'unconditional' else 'conditional'"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="$corresponding-conf-items/@remove eq 'yes'">
        <xsl:attribute name="tr-remove" select="'yes'"/>
      </xsl:if>
      <xsl:if test="$corresponding-conf-items/@linear = 'no'">
        <xsl:attribute name="tr-linear" select="'no'"/>
      </xsl:if>
<!--      <xsl:if test="not(descendant::*[generate-id(.) = $candidate-ids])">-->
        <xsl:apply-templates mode="#current"/>
      <!--</xsl:if>-->
    </xsl:copy>
    <!--<xsl:if test="descendant::*[generate-id(.) = $candidate-ids]">
      <xsl:apply-templates mode="#current"/>
    </xsl:if>-->
  </xsl:template>

  <xsl:template match="*" mode="semiflatten">
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates select="@epub:type|@role" mode="#current"/>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="@epub:type" mode="semiflatten" priority="2">
    <xsl:copy/>
    <xsl:variable name="tokenized" select="tokenize(., '\s+')" as="xs:string+"/>
    <xsl:variable name="landmarks" select="$tokenized[. = $epub3-landmark-types]" as="xs:string*"/>
    <xsl:variable name="non-landmarks" select="$tokenized[not(. = $epub3-landmark-types)]" as="xs:string*"/>
    <xsl:attribute name="tr-epub-type" select="if (exists($non-landmarks)) then $non-landmarks else $landmarks"/>
    <xsl:if test="exists($non-landmarks) and exists($landmarks)">
      <xsl:attribute name="tr-epub-extra-landmark-type" select="$landmarks"/>
    </xsl:if>
  </xsl:template>
  
  
  <xsl:template match="@role" mode="semiflatten" priority="2">
    <xsl:copy/>
    <xsl:variable name="tokenized" select="tokenize(., '\s+')" as="xs:string+"/>
    <xsl:variable name="roles" select="$tokenized[. = $epub3-publisher-roles]" as="xs:string*"/>
    <xsl:variable name="non-roles" select="$tokenized[not(. = $epub3-publisher-roles)]" as="xs:string*"/>
    <xsl:attribute name="tr-role" select="if (exists($non-roles)) then $non-roles else $roles"/>
    <xsl:if test="exists($non-roles) and exists($roles)">
      <xsl:attribute name="tr-epub-extra-role-type" select="$roles"/>
    </xsl:if>
  </xsl:template>

  <xsl:template match="/*" mode="semiflatten">
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@*"/>
      <xsl:attribute name="tr-candidate-ids" select="$candidate-ids"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="@shape | html:colgroup[html:col]/@span" mode="#all" priority="10"/>

  <!-- A signature is a footprint or a hash value for a specific kind of element. It may be calculated 
       for configuration selectors as well as for content items. By means of this signature, configuration
       options may be applied to the content items they pertain to. -->
  <xsl:function name="tr:signature-from-conf" as="xs:string+">
    <xsl:param name="conf-item" as="element()"/>
    <xsl:if test="not($conf-item/@attr = ('class', 'epub:type', 'id', 'role'))">
      <xsl:choose>
        <!-- the current specification is generic, and there is another specification for the same element, but with a specific class: -->
        <xsl:when
          test="some $otheritem in ($conf-item/preceding-sibling::* union $conf-item/following-sibling::*)[name() eq $conf-item/name()]
                    [if ($conf-item/@elt) then @elt = $conf-item/@elt else true()] 
                  satisfies ($otheritem/@attr = ('class', 'epub:type', 'id', 'role'))"/>
        <xsl:otherwise>
          <!-- the current item is generic, and there is no other specification for the same element, but with a specific class: -->
          <xsl:sequence select="$conf-item/@elt"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <!-- For a specification that pertains to a specific class, issue the fully qualified specification in any case:  -->
    <xsl:sequence select="string-join((if ($conf-item/@elt) 
                                       then concat('elt=', $conf-item/@elt) 
                                       else (), 
                                       $conf-item[@attr = ('class', 'epub:type', 'id', 'role')]/(@attr, @attval)
                                      ),
                                      '__'
                                     )"/>
  </xsl:function>

  <xsl:function name="tr:signature-from-doc" as="xs:string+">
    <xsl:param name="elt" as="element()"/>
    <xsl:for-each select="$elt/(@class, @epub:type, @id, @role)">
      <xsl:variable name="att" select="." as="attribute()"/>
      <xsl:for-each select="tokenize(., '\s+')">
        <xsl:sequence select="string-join((name($att), .), '__')"/>
        <xsl:sequence select="string-join((concat('elt=', local-name($elt)), name($att), .), '__')"/>
      </xsl:for-each>
    </xsl:for-each>
    <xsl:sequence select="concat('elt=', local-name($elt))"/>
  </xsl:function>

  <!-- MODE: GROUP-STARTING-WITH-SPLIT-CANDIDATES
       and 
       MODE: RESPECT-HIERARCHY-AMONG-CONDITIONAL-SPLIT-CANDIDATES
       After flattening most of the divs, the headings are on the same level.
       They will be grouped to nested headings. On the topmost level, grouping will
       take place according to unconditional-split. This means that
       the grouping will not necessarily reflect the document's hierarchy exactly. 
       In the first of the two passes, only unconditional-splits and headings will be discerned. 
       In the second one, in addition to further nesting the
       conditional hierarchy, the split content will be subsplit if
       its length exceeds the configured max chunk length.
       The purpose of nested grouping is: to be able to carry out size calculations
       more easily.
       Content that isn't needed for size calculations any more will be discarded. -->
  <xsl:template match="html:body" mode="group-starting-with-split-candidates">
    <xsl:copy copy-namespaces="no">
      <xsl:for-each-group select="*" group-starting-with="*[@tr-splitting-priority eq 'unconditional']">
        <tr-unconditional-split>
          <xsl:copy-of select="@*[starts-with(name(), 'tr')] except @tr-splitting-priority"/>
          <xsl:copy-of select="@id"/>
          <xsl:for-each-group select="current-group()" group-starting-with="*[@tr-splitting-priority eq 'conditional']">
            <xsl:choose>
              <xsl:when test="@tr-splitting-priority eq 'conditional'">
                <tr-conditional-split>
                  <xsl:attribute name="text-length" select="string-length(normalize-space(string-join(current-group(), '')))"/>
                  <xsl:copy-of select="@*[starts-with(name(), 'tr')] except @tr-splitting-priority"/>
                  <xsl:copy-of select="@id"/>
                  <xsl:sequence select="current-group()"/>
                </tr-conditional-split>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="text-length" select="string-length(normalize-space(string-join(current-group(), '')))"/>
                <xsl:sequence select="current-group()"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:for-each-group>
        </tr-unconditional-split>
      </xsl:for-each-group>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="html:tr-unconditional-split" mode="respect-hierarchy-among-conditional-split-candidates">
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@*"/>
      <xsl:variable name="processed" as="element(*)*"
        select="tr:group-according-to-heading(
                  html:tr-conditional-split, 
                  0,
                  @text-length
                )"
      />
      <xsl:attribute name="text-length" select="sum((@text-length, $processed/self::html:content/@text-length))"/>
      <content text-length="{@text-length}">
        <xsl:sequence select="tr:subsplit(* except html:tr-conditional-split, 
                                          (@text-length, 0)[1], 
                                          (ancestor-or-self::*/@tr-max-text-length, $heading-conf/@max-text-length)[1])"/>
      </content>
      <xsl:sequence select="$processed"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:function name="tr:is-conditional-split-level" as="xs:boolean">
    <xsl:param name="level" as="xs:integer?"/>
    <xsl:sequence select="$level &gt; 100"/>
  </xsl:function>

  <xsl:function name="tr:group-according-to-heading" as="element()*">
    <xsl:param name="nodes" as="element()*"/>
    <xsl:param name="level-to-dissolve"/><!-- remaining conditional split points at which no split occurred -->
    <xsl:param name="start-length" as="xs:integer?"/><!-- the length of a first text section before the first conditional split -->
    <xsl:variable name="level" as="xs:integer?" 
      select="for $min in min(for $dv in distinct-values($nodes/self::html:tr-conditional-split/@tr-heading-level[. castable as xs:integer][. &gt; $level-to-dissolve])
                              return xs:double($dv))
              return xs:integer($min)"/>
    <xsl:choose>
      <xsl:when test="not($level)">
        <xsl:sequence select="tr:subsplit($nodes, 
                                          sum(for $n in $nodes return string-length($n)), 
                                          (($nodes/ancestor-or-self::*[@tr-max-text-length])[last()]/@tr-max-text-length, $heading-conf/@max-text-length)[1])"/>
      </xsl:when>
      
      <!-- This seems rather complicated. It might help to look at a resulting debug file, 
        05.respect-hierarchy-among-conditional-split-candidates.xhtml
        There you’ll see some debugging info attached to the remaining <tr-conditional-split> elements.
        A thing that might facilitate calculations might be attaching each element’s position (the string
        length before, plus 1) as an attribute in a previous mode, in addition to the length. -->
      <!-- Remove true() here in order to enable the previous splitting of too long chapters at each section
        (probably need to introduce an option for that) -->
      <xsl:when test="true() or tr:is-conditional-split-level($level)">
        <xsl:variable name="same-level-nodes" as="element(*)*"
          select="$nodes/self::html:tr-conditional-split[@tr-heading-level = $level]"/>
        <xsl:variable name="same-level-total-text-lengths" as="xs:integer*">
          <xsl:for-each-group select="$nodes" group-starting-with="html:tr-conditional-split[@tr-heading-level = $level]">
            <xsl:sequence select="xs:integer(sum(current-group()/@text-length))"/>
          </xsl:for-each-group>
        </xsl:variable>
        <xsl:variable name="max-text-length" as="xs:integer" 
          select="(
                    ($nodes/ancestor-or-self::*[@tr-max-text-length]/@tr-max-text-length)[last()], 
                    $heading-conf/@max-text-length
                  )[1]"/>
        
        <xsl:variable name="same-level-text-offsets"
          select="tr:text-offsets($start-length, 
                                     $same-level-total-text-lengths)"/>
        <xsl:variable name="modulos" as="xs:double*"
          select="for $o in $same-level-text-offsets
                  return $o mod $max-text-length"/>
        <xsl:variable name="flags" select="(for $i in (1 to count($modulos) - 1)
                                            return ($modulos[$i + 1] lt $modulos[$i]
                                                    or 
                                                    $same-level-text-offsets[$i + 1] &gt; $same-level-text-offsets[$i] + $max-text-length) 
                                           )"/>
        <xsl:variable name="indexes" select="index-of($flags, true())"/>
        <xsl:variable name="split-nodes" as="element(*)*" select="$same-level-nodes[position() = $indexes]"/>
        <xsl:for-each-group select="$nodes" group-starting-with="*[some $s in $split-nodes
                                                                   satisfies (. is $s)]">
          <xsl:variable name="subitems" select="current-group()[position() gt 1]"/>
          <xsl:variable name="current-index" select="tr:index-of($same-level-nodes, .)" as="xs:integer?"/>
          <xsl:variable name="current-index-offset-at-start" as="xs:integer?"
            select="if ($current-index &gt; 1) then $same-level-text-offsets[$current-index - 1]
                    else if ($current-index = 1) then $start-length
                    else 0"/>
          <xsl:choose>
            <xsl:when test="some $s in $split-nodes satisfies (. is $s)">
              <tr-conditional-split tr-text-offsets="{$same-level-text-offsets}" tr-indexes="{$indexes}" 
                tr-flags="{$flags}" tr-modulos="{$modulos}">
                <xsl:copy-of select="@*"/>
                <xsl:variable name="current-pos-in-index-list" as="xs:integer" select="index-of($indexes, $current-index)"/>
                <xsl:variable name="next-index" select="$indexes[$current-pos-in-index-list + 1]" as="xs:integer?"/>
                <xsl:variable name="chunk-length" as="xs:integer"
                  select="if ($next-index) 
                          then $same-level-text-offsets[$next-index - 1] - $current-index-offset-at-start
                          else $same-level-text-offsets[last()] - $current-index-offset-at-start"/>
                <xsl:attribute name="current-index-offset-at-start" select="$current-index-offset-at-start"/>
                <xsl:attribute name="next-index" select="$next-index"/>
                <xsl:attribute name="text-length" select="$chunk-length"/>
                <xsl:attribute name="tr-current-index" select="$current-index, $next-index" separator=" "/>
                <content text-length="{@text-length}"  tr-heading-level="{$level}" tr-origin="B">
                  <xsl:sequence select="tr:subsplit(*, @text-length, $max-text-length)"/>
                </content>
                <xsl:for-each-group select="$subitems" 
                  group-starting-with="html:tr-conditional-split[@tr-heading-level cast as xs:integer eq $level]">
                  <content>
                    <xsl:sequence select="tr:subsplit(*, @text-length, $max-text-length)"/>
                  </content>
                  <xsl:sequence
                  select="tr:group-according-to-heading(
                            current-group()[position() gt 1], 
                            $level,
                            @text-length
                          )" />
                </xsl:for-each-group>
              </tr-conditional-split>
            </xsl:when>
            <xsl:otherwise>
              <xsl:for-each-group select="current-group()" 
                  group-starting-with="html:tr-conditional-split[@tr-heading-level = $level]">
                <xsl:choose>
                  <xsl:when test="self::html:tr-conditional-split[@tr-heading-level = $level]">
                    <content text-length="{@text-length}" tr-heading-level="{$level}" tr-origin="C">
                      <xsl:sequence select="tr:subsplit(*, @text-length, $max-text-length)"/>
                    </content>
                    <xsl:sequence
                      select="tr:group-according-to-heading(
                                current-group()[position() gt 1], 
                                $level,
                                @text-length
                              )" />
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence
                      select="tr:group-according-to-heading(
                                current-group(), 
                                $level,
                                0
                              )" />
                  </xsl:otherwise>
                </xsl:choose>  
              </xsl:for-each-group>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:for-each-group>
      </xsl:when>
      <xsl:otherwise>
        <!-- It’s be preferable if we could keep together as many heading groups as fit into max-text-length.
          Therefore, all conditional-split levels (including the headings) are treated by the previous xsl:when.
          If it turns out to be buggy, you can treat the headings with the following, classic code, by
          removing "true() or" above. -->
        <xsl:for-each-group select="$nodes" group-starting-with="html:tr-conditional-split[@tr-heading-level cast as xs:integer eq $level]">
          <xsl:variable name="subitems" select="current-group()[position() gt 1]"/>
          <xsl:variable name="max-text-length" as="xs:integer" 
            select="(
                      ($nodes/ancestor-or-self::*[@tr-max-text-length]/@tr-max-text-length)[last()], 
                      $heading-conf/@max-text-length
                    )[1]"/>
          <tr-conditional-split>
            <xsl:copy-of select="@*"/>
            <content text-length="{@text-length}">
              <xsl:sequence select="tr:subsplit(*, @text-length, $max-text-length)"/>
            </content>
            <xsl:sequence
              select="tr:group-according-to-heading(
                        $subitems,
                        $level,
                        @text-length
                      )"
            />
          </tr-conditional-split>
        </xsl:for-each-group>
      </xsl:otherwise>
<!--      </xsl:otherwise>
        <xsl:sequence select="$nodes"/>
      </xsl:otherwise>
-->    </xsl:choose>
  </xsl:function>
  
  <xsl:function name="tr:text-offsets" as="xs:integer*">
    <xsl:param name="start" as="xs:integer*"/>
    <xsl:param name="deltas" as="xs:integer*"/>
    <xsl:variable name="_start" as="xs:integer+" select="if (not(empty($start))) then $start else 0"/>
    <xsl:sequence select="if (count($deltas) gt 0)
                          then tr:text-offsets(($start, $start[last()] + $deltas[1]), $deltas[position() gt 1])
                          else $start"/>
  </xsl:function>

  <xsl:function name="tr:subsplit" as="node()*">
    <xsl:param name="nodes" as="node()*"/>
    <xsl:param name="length" as="xs:double"/>
    <xsl:param name="max-length" as="xs:double"/>
    <xsl:choose>
      <xsl:when test="$length le number($max-length)">
        <xsl:sequence select="$nodes"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:for-each-group select="$nodes"
          group-starting-with="*[position() mod ((last() idiv (($length idiv number($max-length)) + 1)) + 1) eq 0]">
          <xsl:if test="position() gt 1">
            <tr-subsplit text-length="{string-length(normalize-space(string-join(current-group(), '')))}"
              tr-generated-id="{@tr-generated-id}"/>
          </xsl:if>
        </xsl:for-each-group>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>


  <!-- MODE: PARTIALLY-UNGROUP-TO-FINAL-SPLIT-POINTS
       Conditional splitting points will be removed if chunking is already small enough without them.
       Content that has been preserved in order to carry out subsplit size calculations will now be removed.
       One of two possible reasons will be given if a splitting point is put out of service:
       * the parent heading's group is short enough anyway, or
       * there is only minimal introductory content before the conditional split. 
       -->
  <xsl:template match="*[number(@text-length) 
                         le 
                         number((ancestor-or-self::*[@tr-max-text-length][1]/@tr-max-text-length, 
                                 $heading-conf/@max-text-length)[1])]/html:content"
    mode="partially-ungroup-to-final-split-points"/>


  <xsl:template match="*[number(@text-length)
                         gt 
                         number((ancestor-or-self::*[@tr-max-text-length][1]/@tr-max-text-length, 
                                 $heading-conf/@max-text-length)[1])]/html:content"
    mode="partially-ungroup-to-final-split-points">
    <xsl:sequence select=".//html:tr-subsplit"/>
  </xsl:template>

  <xsl:template
    match="html:tr-conditional-split[
             sum(
               for $l in (
                 ../@text-length,
                 ..//html:tr-conditional-split/@text-length
               ) return number($l)
             ) le number((../@tr-max-text-length, $heading-conf/@max-text-length)[1])
           ]/@tr-generated-id"
    mode="partially-ungroup-to-final-split-points" priority="4">
    <xsl:attribute name="tr-dont-split-at-genid" select="."/>
    <xsl:attribute name="tr-reason" select="'parent-short-enough'"/>
  </xsl:template>

    <!-- close enough to previous headings: -->
  <xsl:template
    match="html:tr-conditional-split[
             sum(
               for $l in (
                 preceding-sibling::html:tr-conditional-split//@text-length, 
                 ../@text-length
               ) return number($l)
             ) le number((../@tr-max-text-length, $heading-conf/@max-text-length)[1]) * 0.03 ]"
    mode="partially-ungroup-to-final-split-points">
    <!-- only the subsplits (if present), but don't split here because it's too close to the parent heading -->
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@* except @tr-generated-id"/>
      <xsl:attribute name="tr-dont-split-at-genid" select="@tr-generated-id"/>
      <xsl:attribute name="tr-reason" select="'parent-introduction-short-enough'"/>
      <xsl:apply-templates select="html:content/html:tr-subsplit union html:tr-conditional-split" mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <!-- OUTPUT FILE NAMES -->
  
  <xsl:function name="tr:epub-type" as="xs:string">
    <xsl:param name="att" as="attribute(tr-epub-type)"/>
    <xsl:variable name="tokenized-types" select="tokenize($att, '\s+')" as="xs:string+"/>
    <xsl:variable name="first-available-type-in-conf" as="element(type)?" select="($epub-config/types/type[@name = $tokenized-types])[1]"/>
    <xsl:sequence select="string(($first-available-type-in-conf/@name, $att)[1])"/>
  </xsl:function>
  
  <xsl:template match="@tr-generated-id[../@tr-epub-type]" mode="output-file-names">
    <xsl:copy/>
    <xsl:variable name="same-type" 
      select="ancestor::*[last()]//@tr-epub-type[
                tr:epub-type(.) = tr:epub-type(current()/../@tr-epub-type) and 
                not(../@tr-dont-split-at-genid = current()/../@tr-generated-id)
              ]" as="attribute(tr-epub-type)+"/>
    <xsl:variable name="type-index" as="xs:integer" select="tr:index-of($same-type, ../@tr-epub-type)"/>
    <xsl:variable name="looked-up-name-component" select="$epub-config/types/type[@name = tr:epub-type(current()/../@tr-epub-type)]/(@file, @name)[1]" as="xs:string*"/>
    <xsl:if test="count($looked-up-name-component) gt 1">
      <xsl:message select="concat('[WARNING] more than one occurence of epub type ', string-join($epub-config/types/type[@name = tr:epub-type(current()/../@tr-epub-type)][1]/@name, ''),   ' in config. First occurence is used for file name extraction.')"/>
    </xsl:if>
    <xsl:variable name="normalized" select="if ($looked-up-name-component[1]) 
                                            then $looked-up-name-component[1] 
                                            else replace(replace(../@tr-epub-type, '^.+:', ''), '[^-_a-z0-9]', '_')" as="xs:string"/>
    <xsl:variable name="normalized" select="concat($html-prefix, $normalized)" as="xs:string"/>
    <xsl:attribute name="tr-output-name" 
      select="replace(
                $orig-filename, 
                '.+(\..+)$',
                concat(
                  if (count($same-type) gt 1) 
                  then concat($normalized, '-', tr:custom-pad(string($type-index), 3))
                  else $normalized,
                  '.xhtml'
                )
              )"/>
  </xsl:template>

  <xsl:template match="@tr-generated-id[not(../@tr-epub-type)]" mode="output-file-names">
    <xsl:copy/>
    <xsl:attribute name="tr-output-name" 
      select="replace(
                concat($html-prefix, $orig-filename), 
                '(\..+)$', 
                concat(
                  '_', 
                  tr:custom-pad(., 6),
                  if (../@tr-linear = 'no') then '_nolin' else '',
                  '.xhtml'
                )
              )"/>
  </xsl:template>


  <!-- Page list: -->

  <xsl:variable name="pgl" as="element(html:pgl)?">
    <xsl:variable name="pagenum-elts" as="element(*)*" select="tr:pagenums($chunks/html:chunks)"/>
    <xsl:if test="exists($pagenum-elts)">
      <pgl>
        <xsl:for-each select="$chunks/html:chunks/html:chunk">
          <xsl:variable name="filename" select="replace(@file, '^.+/', '')" as="xs:string"/>
          <xsl:variable name="chunk-pagenum-elts" as="element(*)*" select="tr:pagenums(.)"/>
          <xsl:for-each select="$chunk-pagenum-elts">
            <page name="{(self::*[@epub:type = 'pagebreak']/@title, 
                          self::*[@epub:type = 'pagebreak'][normalize-space()], 
                          replace(@id, '^page_?', '')
                         )[1]}" href="{$filename}{concat('#', @id)}"
              playOrder="{replace(generate-id(($root//*[@id eq current()/@id])[1]), '^.+?(\d+)$', '$1')}">
              <xsl:if test="position() eq 1">
                <xsl:attribute name="page-map-href" select="$filename"/>
              </xsl:if>
            </page>
          </xsl:for-each>
          <!-- fix for Sony reader bug (not able to flip back a page if a split file is not mentioned in page-map.xml) -->
          <xsl:if test="not($pagenum-elts/@epub:type = 'pagebreak')
                        and 
                        not(.//html:a[starts-with(@id, 'page_')]) 
                        and 
                        preceding-sibling::html:chunk//html:a[starts-with(@id, 'page_')]">
            <page name="" page-map-href="{$filename}"/>
          </xsl:if>
        </xsl:for-each>
      </pgl>
    </xsl:if>
  </xsl:variable>

  <xsl:function name="tr:pagenums" as="element(*)*">
    <xsl:param name="elts" as="element(*)"/><!-- a, span, … -->
    <xsl:variable name="a_page_" select="$elts//html:a[starts-with(@id, 'page_')]" as="element(html:a)*"/>
    <xsl:variable name="epub-typed" select="$elts//*[@epub:type = 'pagebreak']
                                                    [exists(@title) or normalize-space()]" as="element(*)*"/>
    <xsl:choose>
      <xsl:when test="exists($epub-typed)">
        <xsl:sequence select="$epub-typed"/>
      </xsl:when>
      <xsl:when test="exists($a_page_)">
        <xsl:sequence select="$a_page_"/>
      </xsl:when>
    </xsl:choose>
  </xsl:function>

  <xsl:function name="tr:sort" as="item()*">
    <xsl:param name="sequence" as="item()*"/>
    <xsl:for-each select="$sequence">
      <xsl:sort select="."/>
      <xsl:copy-of select="."/>
    </xsl:for-each>
  </xsl:function>

  <xsl:variable name="playOrder-generated-ids" as="xs:string*"
    select="for $i in tr:sort(
              distinct-values(
                for $n in ($raw-ncx//@playOrder union $pgl//@playOrder)
                return xs:integer($n)
              )
            ) 
            return xs:string($i)"/>

  <xsl:template match="html:pgl" mode="pageList">
    <pageList xmlns="http://www.daisy.org/z3986/2005/ncx/">
      <xsl:apply-templates mode="#current"/>
    </pageList>
  </xsl:template>

  <xsl:template match="html:pgl/html:page[not(@href)]" mode="pageList"/>

  <xsl:template match="html:pgl/html:page[@href]" mode="pageList">
    <pageTarget id="page_{@name}" type="normal" value="{@name}" xmlns="http://www.daisy.org/z3986/2005/ncx/"
      playOrder="{index-of($playOrder-generated-ids, @playOrder)}">
      <navLabel xmlns="http://www.daisy.org/z3986/2005/ncx/">
        <text xmlns="http://www.daisy.org/z3986/2005/ncx/">
          <xsl:value-of select="@name"/>
        </text>
      </navLabel>
      <content src="{concat($html-prefix, @href)}" xmlns="http://www.daisy.org/z3986/2005/ncx/"/>
    </pageTarget>
  </xsl:template>

  <xsl:template match="html:pgl" mode="page-map">
    <xsl:message>Writing page-map.xml</xsl:message>
    <xsl:result-document href="{$datadir}/chunks/page-map.xml" format="xml">
      <page-map xmlns="http://www.idpf.org/2">
        <xsl:apply-templates mode="#current"/>
      </page-map>
    </xsl:result-document>
  </xsl:template>

  <xsl:template match="html:pgl/html:page" mode="page-map">
    <page xmlns="http://www.idpf.org/2">
      <xsl:apply-templates select="@*" mode="#current"/>
    </page>
  </xsl:template>

  <xsl:template match="@page-map-href" mode="page-map">
    <xsl:attribute name="href" select="."/>
  </xsl:template>

  <xsl:template match="@href[../@page-map-href]" mode="page-map"/>

  <xsl:template match="@playOrder" mode="page-map"/>

  <!-- MODE: fullflatten -->
  
  <!-- a div or similar that could not be dissolved. It is not a heading by itself, but probably a 
    location for an unconditional split. Since the input for generation must be flat (so that it can
    be hierarchized…), we must dissolve every container that contains headings. -->
  <xsl:template match="*[@tr-splitting-priority]
                        [not(@tr-heading-level)]
                        [exists(
                          descendant::*/@tr-heading-level
                          union
                          descendant::*[tr:contains-token(@class, ('TOC_same', 'TOC_sub'))]
                        )]" mode="fullflatten">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
    </xsl:copy>
    <xsl:apply-templates mode="#current"/>
  </xsl:template>
  
  <xsl:template match="*[tr:contains-token(@class, 'TOC_same')]" mode="fullflatten">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:copy-of select="preceding::*[@tr-heading-level][1]/@tr-heading-level"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="*[tr:contains-token(@class, 'TOC_sub')]" mode="fullflatten">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:for-each select="preceding::*[@tr-heading-level][1]/@tr-heading-level">
        <xsl:attribute name="{name()}" select="number(.) + 1"/>
      </xsl:for-each>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <!-- NCX (ToC) EXPORT: -->

  <xsl:template match="html:html" mode="raw-ncx">
    <xsl:variable name="first-export-file"
      select="tr:export-filename(($output-file-names/html:html/html:body//@tr-generated-id)[1])"/>
    <navMap xmlns="http://www.daisy.org/z3986/2005/ncx/" tr-first-export-file="{$first-export-file}">
      <xsl:choose>
        <xsl:when test="html:body/*/@tr-heading-level[not(../@tr-exclude-from-nav)]
                                                     [not(tr:is-conditional-split-level(.))]">
          <xsl:sequence select="tr:group-for-ncx(
                                  html:body/*, 
                                  xs:integer(min(html:body/*/@tr-heading-level[not(../@tr-exclude-from-nav)]
                                                                              [not(tr:is-conditional-split-level(.))])), 
                                  true()
                                )"/>
        </xsl:when>
        <xsl:when test="html:body//@tr-heading-level[not(tr:is-conditional-split-level(.))]">
          <xsl:variable name="first-container-with-tr-heading-level-elements" as="element()"
            select="(.//*[*[@tr-heading-level[not(tr:is-conditional-split-level(.))]]])[1]"/>
          <xsl:sequence select="tr:group-for-ncx(
                                  $first-container-with-tr-heading-level-elements/*, 
                                  xs:integer(min($first-container-with-tr-heading-level-elements/*/@tr-heading-level[not(tr:is-conditional-split-level(.))])), 
                                  true()
                                )"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message
            select="'&#xa;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#xa;',
            'INFO: No heading elements found. All content will be written to one file.&#xa; Please consider your configuration file.',
            '&#xa;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#xa;'"/>
          <navPoint id="" class="default" playOrder="1" xmlns="http://www.daisy.org/z3986/2005/ncx/">
            <navLabel xmlns="http://www.daisy.org/z3986/2005/ncx/">
              <text xmlns="http://www.daisy.org/z3986/2005/ncx/">***</text>
            </navLabel>
            <content src="{$first-export-file}" xmlns="http://www.daisy.org/z3986/2005/ncx/"/>
          </navPoint>
        </xsl:otherwise>
      </xsl:choose>
    </navMap>
  </xsl:template>

  <xsl:template match="html:br" mode="br-to-space">
    <xsl:text> </xsl:text>
  </xsl:template>

  <xsl:template match="html:a" mode="br-to-space"/>

  <xsl:template match="html:span[@class='chapterauthor']" mode="br-to-space">
    <xsl:apply-templates select="node()" mode="#current"/>
    <xsl:text>– </xsl:text>
  </xsl:template>

  <!-- add @epub:type="pagebreak" to page anchors (normally, these a elements should be renamed to span)
       see
       https://www.w3.org/TR/dpub-aria-1.0/#doc-pagebreak
       http://kb.daisy.org/publishing/docs/html/dpub-aria/doc-pagebreak.html
  -->
  <xsl:template match="html:a[starts-with(@id, 'page_')]" mode="remove-surrounding-text">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:if test="$final-pub-type eq 'EPUB3'">
        <xsl:attribute name="epub:type" select="'pagebreak'"/>
        <xsl:attribute name="role" select="'doc-pagebreak'"/>
        <xsl:attribute name="title" select="replace(@id, '^page_?', '')"/>
        <xsl:attribute name="aria-label" select="replace(@id, '^page_?', '')"/>
      </xsl:if>
      <xsl:apply-templates select="node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <!-- preserve newlines in pre tags -->
  
  <xsl:template match="html:pre" mode="remove-surrounding-text">
    <xsl:copy-of select="."/>
  </xsl:template>

  <xsl:template name="ncx">
    <ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1" xml:lang="en-US">
      <!-- to-do: copy metadata information -->
      <head>
        <meta name="dtb:uid"
          content="{if ($metadata/dc:identifier[@opf:scheme eq 'ISBN'])
          then $metadata/dc:identifier[@opf:scheme eq 'ISBN'] 
          else tr:get-dc-identifier()}"
        />
      </head>
      <docTitle>
        <text>
          <xsl:value-of select="$metadata/dc:title"/>
        </text>
      </docTitle>
      <xsl:apply-templates select="$raw-ncx" mode="play-order"/>
      <xsl:apply-templates select="$pgl" mode="pageList"/>
    </ncx>
  </xsl:template>

  <!-- EPUB Navigation Document, EPUB 3.0, supersedes NCX -->
  <!-- body class to avoid displaying or styling via CSS -->
  <xsl:template name="toc-nav">
    <xsl:param name="toc-ncx" as="element(ncx:ncx)"/>
    <xsl:param name="landmarks" as="element(*)*"/>
    <html epub:prefix="tr: http://transpect.io">
      <xsl:apply-templates select="$root/html:html/(@xml:lang, @lang)" mode="#current"/>
      <head>
        <link href="styles/stylesheet.css" type="text/css" rel="stylesheet"/>
        <title>EPUB Navigation: Toc</title>
        <xsl:choose>
          <xsl:when test="$epub-config/types/type[@name = 'toc']/@hidden = 'true'">
            <!-- I thought about <meta name="spine" content="false"/> but then there’s the link
            from the landmarks nav to the toc nav and this necessitates that the whole nav doc 
            is in the spine. I’ll make it linear=no. 
            The issue that I’m trying to solve is that the generated nav doc appears first in 
            spine, right before the cover.
            It wasn’t skipped in Bluefire, therefore reverting to spine=false, removing the 
            link in the generated landmarks. -->
            <meta name="spine" content="false"/>
          </xsl:when>
          <xsl:otherwise>
            <!-- so that the generated cover will be sorted between cover 
              (sequence # 1) and the remainder of the exported files -->
            <meta name="sequence" content="{($epub-config/types/@nav-spine-pos, 1.5)[1]}"/>
          </xsl:otherwise>
        </xsl:choose>
        
      </head>
      <body class="nav-body">
        <xsl:call-template name="landmarks">
          <xsl:with-param name="landmarks" select="$landmarks"/>
        </xsl:call-template>
        <nav epub:type="toc" role="doc-toc" id="{$toc-nav-id}">
          <xsl:if test="not($epub-config/types/type[@name = 'toc']/@heading = '')">
            <h1>
              <xsl:value-of select="($epub-config/types/type[@name = 'toc']/@heading, 'Table of Contents')[1]"/>
            </h1>
          </xsl:if>
          <ol>
            <xsl:apply-templates select="$toc-ncx/ncx:navMap" mode="nav-xhtml"/>
          </ol>
        </nav>
        <xsl:call-template name="create-lof"/>
        <xsl:if test="$pgl and not($final-pub-type = ('EPUB2'))">
          <xsl:call-template name="page-list-nav-inner"/>
        </xsl:if>
      </body>
    </html>
  </xsl:template>

  <xsl:template match="*[@epub:type = ('loi', 'lot')]
                        [@class = 'as-nav']" mode="#all">
    <xsl:param name="transform-lof-to-nav" as="xs:boolean?" tunnel="yes"/>
    <xsl:if test="$transform-lof-to-nav">
      <nav>
        <xsl:apply-templates select="@*, node()" mode="#current"/>
      </nav>
    </xsl:if>
  </xsl:template>

  <xsl:template name="create-lof">
    <!-- if sections with @class="as-nav" → create nav elements and discard from content -->
    
    <xsl:if test="not($final-pub-type = ('EPUB2'))
                  and
                  exists((//*, $root//*)[@epub:type = ('loi', 'lot')]
                            [@class = 'as-nav'])">
      <xsl:apply-templates select="(//*, $root//*)[@epub:type = ('loi')][@class = 'as-nav'][1] |
                                   (//*, $root//*)[@epub:type = ('lot')][@class = 'as-nav'][1]" mode="resolve-refs">
        <xsl:with-param name="transform-lof-to-nav" as="xs:boolean"  select="true()" tunnel="yes"/>
    </xsl:apply-templates>
    </xsl:if>
  </xsl:template>
  
  <xsl:variable name="toc-nav-id" select="'toc-navigation'" as="xs:string"/>

  <!-- only page-list-nav-inner seems to be used -->
  <xsl:template name="page-list-nav">
    <xsl:param name="toc-ncx" as="element(ncx:ncx)"/>
    <xsl:param name="landmarks" as="element(*)*"/>
    <html>
      <xsl:apply-templates select="$root/html:html/(@xml:lang, @lang)" mode="#current"/>
      <head>
        <link href="styles/stylesheet.css" type="text/css" rel="stylesheet"/>
        <title>EPUB Navigation: Page list</title>
      </head>
      <body class="nav-body">
        <xsl:call-template name="page-list-nav-inner"/>
      </body>
    </html>
  </xsl:template>
  
  <xsl:template name="page-list-nav-inner">
    <xsl:variable name="nav" as="element(html:chunk)?" 
                  select="ancestor::html:chunk"/>
    <nav epub:type="page-list" id="page-list-navigation" hidden="hidden">
      <xsl:if test="$final-pub-type eq 'EPUB3'">
        <xsl:attribute name="role" select="'doc-pagelist'"/>
      </xsl:if>
      <ol>
        <xsl:for-each select="$pgl/html:page[normalize-space(@name)]">
          <xsl:variable name="resolved-href" as="xs:string">
            <xsl:apply-templates select="@href" mode="resolve-refs">
              <xsl:with-param name="element" select="."/>
            </xsl:apply-templates>
          </xsl:variable>
          <li>
            <!-- if <nav> is stored in $html-subdir-name dir rather than OEBPS/nav.xhtml,
                 this conditional fixes the path -->
            <a href="{if(replace($nav/@file, '^.+/(.+?)/.+$', '$1') = replace($html-prefix, '/', ''))
                      then $resolved-href
                      else concat($html-prefix, $resolved-href)}" srcpath="pgl_{generate-id()}">
              <xsl:value-of select="@name"/>
            </a>
          </li>
        </xsl:for-each>
      </ol>
    </nav>
  </xsl:template>

  <xsl:template name="landmarks">
    <xsl:param name="landmarks" as="element(*)*"/>
    <!-- If this exists ⇒ The toc is already in the content -->
    <xsl:variable name="content-toc-id" as="attribute()?"
      select="($landmarks[tr:contains-token(@epub:type, 'toc')]/(@id, @tr-generated-id))[1]"/>
    <nav epub:type="landmarks" id="landmarks-navigation">
      <xsl:if test="$epub-config/types/type[@name = 'landmarks']/@hidden = 'true'">
        <xsl:attribute name="hidden" select="'hidden'"/>
      </xsl:if>
      <xsl:if test="not($epub-config/types/type[@name = 'landmarks']/@heading = '')">
        <h1>
          <xsl:value-of select="($epub-config/types/type[@name = 'landmarks']/@heading, 'Guide')[1]"/>
        </h1>
      </xsl:if>
      <ol>
        <xsl:variable name="rendered-toc" as="element(*)?"
          select="key('by-id', $epub-config/types/type[@name = 'toc']/@fallback-id-for-landmark)"/>
        <xsl:variable name="toc-link" as="element(html:li)?">
          <xsl:choose>
            <xsl:when test="not($content-toc-id) and 
                            not($epub-config/types/type[@name = 'toc']/@hidden = 'true')">
              <!-- nav doc is not already in spine, but generated toc will be.
                Link to generated toc. 
                Otherwise, don’t link to generated because it is not allowed to link to non-spine items -->
              <li>
                <a epub:type="toc" href="{concat(if (not($final-pub-type = 'EPUB2'))
                                                 then concat(($epub-config/types/type[@name = 'toc']/@file[normalize-space()], 'nav')[1], '.xhtml') 
                                                 else (), 
                                                 '#', 
                                                 $toc-nav-id
                                           )}" srcpath="landmarks-link-to-toc">
                  <xsl:value-of select="($epub-config/types/type[@name = 'toc']/@heading, 'Table of Contents')[1]"/>
                </a>
              </li>
            </xsl:when>
            <xsl:when test="$epub-config/types/type[@name = 'toc']/@hidden = 'true'
                                                and
                                                exists($rendered-toc)">
              <xsl:variable name="unresolved-href" as="attribute(href)">
                <xsl:attribute name="href" select="concat('#', $epub-config/types/type[@name = 'toc']/@fallback-id-for-landmark)"/>
              </xsl:variable>
              <li>
                <a epub:type="toc" srcpath="landmarks-link-to-toc">
                  <xsl:apply-templates select="$unresolved-href" mode="resolve-refs">
                    <xsl:with-param name="element" select="$rendered-toc"/>
                  </xsl:apply-templates>
                  <xsl:value-of select="($epub-config/types/type[@name = 'toc']/@heading, 'Table of Contents')[1]"/>
                </a>
              </li>
            </xsl:when>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="prelim" as="element(html:li)*">
          <xsl:apply-templates select="$landmarks" mode="nav-landmarks"/>
        </xsl:variable>
        <!-- sorting entries to avoid that toc is always rendered first if not in content -->
        <xsl:variable name="orig-type-order" as="xs:string*" select="tokenize($epub-config/types/type[@name = 'landmarks']/@types, ' ')"/>
        <xsl:variable name="toc-pos" as="xs:integer?" select="index-of($orig-type-order, 'toc')"/>
        <xsl:choose>
          <xsl:when test="empty($toc-link)">
          <!-- if toc already exists, render it where it was -->
          <xsl:sequence select="$prelim"/>
          </xsl:when>
          <xsl:when test="(some $token in $orig-type-order satisfies $token = 'toc') 
                          and 
                          $epub-config/types/@nav-spine-pos" >
          <!-- insert generated toc where it is located in   <type name="landmarks" types=""/> -->
          <xsl:sequence select="$prelim[descendant::*:a/@epub:type[index-of($orig-type-order, .) lt $toc-pos]],
                                $toc-link, 
                                $prelim[descendant::*:a/@epub:type[index-of($orig-type-order, .) gt $toc-pos]]"/>
          </xsl:when>
          <xsl:otherwise>
            <!-- if generated toc is not contained in landmarks/@types and no types/@nav-spine-pos is set, insert it directly after Cover -->
            <xsl:sequence select="$prelim[descendant::*:a/@epub:type = 'cover'], $toc-link, $prelim[not(descendant::*:a/@epub:type = 'cover')]"/>
          </xsl:otherwise>
        </xsl:choose>
        <!-- That would discard an index landmark in a backmatter chunk: --> 
        <!--<xsl:for-each-group select="$prelim" group-by="replace(html:a/@href, '#.+$', '')">
          <xsl:sequence select="."/>
        </xsl:for-each-group>-->
      </ol>
    </nav>
  </xsl:template>

  <xsl:template match="*" mode="nav-landmarks">
    <xsl:variable name="landmark-type" as="xs:string+" select="tokenize(@epub:type, '\s+')[. = $landmark-types]"/>
    <li>
      <a srcpath="landmarks-{generate-id()}">
        <xsl:attribute name="epub:type" select="string-join($landmark-type, ' ')"/>
        <xsl:variable name="unresolved-href" as="attribute(href)">
          <xsl:attribute name="href" select="concat('#', (@id, @tr-generated-id, .[empty(@id)]/html:a/@id, .[empty(@id)]/html:section[1]/@id)[1])"/>
        </xsl:variable>
        <xsl:apply-templates select="$unresolved-href" mode="resolve-refs">
          <xsl:with-param name="element" select="."/>
        </xsl:apply-templates>
        <xsl:value-of select="($epub-config/types/type[@name = $landmark-type]/@heading, $landmark-type)[1]"/>
      </a>
    </li>
  </xsl:template>

  <!-- put spine linear info into meta -->
  <xsl:template match="html:head" mode="resolve-refs">
    <xsl:param name="pos" tunnel="yes"/>
    <xsl:copy>
      <xsl:apply-templates select="@*, node()" mode="#current"/>
      <xsl:if test="../../@tr-linear = 'no'">
        <meta name="linear" content="false"/>
      </xsl:if>
      <meta name="sequence" content="{$pos}"/>
    </xsl:copy>
  </xsl:template>

  <!-- for tocs that are already in the content (should match html:nav instead of *, but people are 
    sometimes using <h1 epub:type="toc"> and the like): -->
  <xsl:template match="*[@epub:type = 'toc']" mode="resolve-refs">
    <xsl:param name="landmarks" as="element(*)*" tunnel="yes"/>
    <xsl:call-template name="landmarks">
      <xsl:with-param name="landmarks" select="$landmarks"/>
    </xsl:call-template>
    <xsl:next-match/>
    <xsl:call-template name="create-lof"/>
    <xsl:if test="$pgl and not($final-pub-type = ('EPUB2'))">
      <xsl:call-template name="page-list-nav-inner"/>
    </xsl:if>
  </xsl:template>
  
  <xsl:template match="@error-message|@aria-labelledby[empty(key('chunk-by-id', ., ancestor::html:chunk))]" mode="resolve-refs"/>

  <xsl:template match="ncx:ncx | ncx:navMap | ncx:navLabel | ncx:text" mode="nav-xhtml">
    <xsl:apply-templates mode="#current"/>
  </xsl:template>

  <xsl:template match="ncx:navPoint" mode="nav-xhtml">
    <xsl:choose>
      <xsl:when test="ncx:navPoint and not( parent::navMap )">
        <li>
          <xsl:apply-templates select="@id | @class" mode="#current"/>
          <xsl:apply-templates select="ncx:content" mode="#current"/>
          <ol>
            <xsl:apply-templates select="ncx:navPoint" mode="#current"/>
          </ol>
        </li>
      </xsl:when>
      <xsl:otherwise>
        <li>
          <xsl:apply-templates select="@id | @class" mode="#current"/>
          <xsl:apply-templates select="ncx:content" mode="#current"/>
        </li>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <xsl:template match="ncx:navPoint[preceding-sibling::ncx:navPoint[@playOrder = current()/@playOrder]]"
    priority="2" mode="#all">
    <!-- hack to fix duplicate TOC_sub entries, https://redmine.le-tex.de/issues/8015#note-32 -->
  </xsl:template>

  <xsl:template match="ncx:content" mode="nav-xhtml">
    <a href="{@src}" srcpath="nav-{generate-id()}">
      <xsl:apply-templates select="preceding-sibling::ncx:navLabel[1]" mode="#current"/>
    </a>
  </xsl:template>


  <xsl:function name="tr:group-for-ncx" as="element()*">
    <xsl:param name="nodes" as="element()*"/>
    <xsl:param name="level" as="xs:integer"/>
    <xsl:param name="topmost" as="xs:boolean"/>
    <xsl:for-each-group select="$nodes" 
      group-starting-with="*[@tr-heading-level[not(../@tr-exclude-from-nav)]][xs:integer(@tr-heading-level) = $level][not(@dissolved-for-semiflatten eq 'true')]">
      <xsl:choose>
        <xsl:when test="xs:integer(@tr-heading-level) = $level">
          <xsl:variable name="actual-heading"
            select="if (@tr-split-for) then key('by-genid', @tr-split-for, $root) else ." as="element()"/>
            <xsl:if test="not(tr:contains-token($actual-heading/@class, '_notoc'))">
            <navPoint id="" class="default" playOrder="{replace(@tr-generated-id, '^.+?(\d+)$', '$1')}"
              xmlns="http://www.daisy.org/z3986/2005/ncx/">
              <navLabel xmlns="http://www.daisy.org/z3986/2005/ncx/">
                <xsl:variable name="br-to-space" as="xs:string">
                  <xsl:choose>
                    <xsl:when test="$actual-heading/(@title | svg:title)">
                      <xsl:value-of select="$actual-heading/(@title | svg:title)"/>
                    </xsl:when>
                    <xsl:when test="tr:is-conditional-split-level($level)">
                      <xsl:choose>
                        <xsl:when test="matches($actual-heading, '^[\s\p{Po}\p{So}]+$')
                                        and matches($actual-heading, '[\p{Po}\p{So}]')">
                          <xsl:value-of 
                            select="string-join((
                                      normalize-space($actual-heading),
                                      tr:abbreviate-for-toc($actual-heading/following-sibling::*[matches(., '[\p{L}\p{N}]')][1])
                                    ), '&#xa;&#xa;')"/>
                        </xsl:when>
                        <xsl:when test="matches($actual-heading, '^[\s\p{Zs}]*$')">
                          <xsl:value-of 
                            select="tr:abbreviate-for-toc($actual-heading/following-sibling::*[matches(., '[\p{L}\p{N}]')][1])"/>
                        </xsl:when>
                        <xsl:otherwise>
                          <xsl:value-of 
                            select="tr:abbreviate-for-toc($actual-heading)"/>
                        </xsl:otherwise>
                      </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:apply-templates select="$actual-heading" mode="br-to-space"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:variable>
                <text xmlns="http://www.daisy.org/z3986/2005/ncx/">
                  <xsl:value-of
                    select="translate(replace(normalize-space($br-to-space), '&#x2009;', ' '), '&#x2011;&#x202f;', '- ')"/>
                </text>
              </navLabel>
              <xsl:variable name="genid" as="xs:string"
                select="if(@tr-source-element-without-id-attribute and @tr-split-delegation-to ne '')
                      then $fullflatten//*[@tr-generated-id[. eq current()/@tr-split-delegation-to]]/@id
                      else (@id, @tr-generated-id, .//@id)[1]"/>
              <content genid="{$genid}" xmlns="http://www.daisy.org/z3986/2005/ncx/"/>
              <xsl:variable name="next-level" as="xs:integer*"
                select="(current-group() except .)/@tr-heading-level[not(tr:is-conditional-split-level(.))]"/>
              <!--<xsl:message select="'nl1 ', $next-level"></xsl:message>-->
              <xsl:if test="min($next-level) = $level">
                <!-- GI 2017-02-25: I’ve seen this message raised when processing the interview in the backmatter of
                  unionsverlag/legacy/00399. It was a conditional split with level=102 (corresponds to p.emptyline
                  in the UV splitting conf). The result looks ok. Haven’t investigated whether the message is 
                  rightfully raised or whether it can be suppressed. -->
                <xsl:message>Something's wrong (msg a): same level <xsl:value-of select="$level"/> in <xsl:sequence
                    select="(current-group() except .)[position() = (1 to 3)]"/> … <xsl:sequence
                    select="(current-group() except .)[last()]"/>
                </xsl:message>
              </xsl:if>
              <xsl:if test="exists($next-level)">
                <!--<nl min="{min($next-level)}" levels="{$next-level}"/>-->
                <xsl:sequence select="tr:group-for-ncx(current-group()
                                                       except ., min($next-level), false())"/>
              </xsl:if>
              <!-- https://redmine.le-tex.de/issues/8015
              The following will only give the results in correct order if there is no mix between proper heading
              and TOC_sub headings. -->
              <xsl:apply-templates select="current-group()/descendant-or-self::*[@tr-heading-level[. = current()/@tr-heading-level + 1]]
                                                        [tr:contains-token(@class, 'TOC_sub')]"
                                   mode="raw-ncx"/>
            </navPoint>
            <xsl:apply-templates select="current-group()/descendant-or-self::*[@tr-heading-level[. = current()/@tr-heading-level]]
                                                      [tr:contains-token(@class, 'TOC_same')]"
                                 mode="raw-ncx"/>
          </xsl:if>

        </xsl:when>
        <xsl:when test="current-group()//@tr-heading-level[not(../@tr-split-delegation-to)][not(../@tr-exclude-from-nav)]">
          <!-- lower level (i.e., higher integer number – may occur in 1st group) -->
          <!--<xsl:message select="'nl2 level ', $level, ', ', min(current-group()//@tr-heading-level)"></xsl:message>-->
          <xsl:if test="min(current-group()//@tr-heading-level[not(../@tr-split-delegation-to)][not(../@tr-exclude-from-nav)]) = $level">
            <xsl:message>Something's wrong (msg b): same level <xsl:value-of select="$level"/> at current group first item
                <xsl:sequence select="."/> in <xsl:sequence select="(current-group() except .)[position() = (1 to 5)]"/>… 
              Possible issue: there are headings deeply nested in the markup above. 
              A solution might be to add the nesting tags in the list of dissolvable
              elements in tr:dissolvable-for-semiflatten(). </xsl:message>
          </xsl:if>
          <xsl:sequence
            select="tr:group-for-ncx(current-group(), xs:integer(min(current-group()//@tr-heading-level)), false())"/>
        </xsl:when>
        <xsl:when test="$topmost 
                        and 
                        (matches(string-join(current-group(), ''), '\S'))
                        and 
                        not( (: nav entry should be suppressed if @generated-frontmatter-title='' :)
                          exists($heading-conf/@generated-frontmatter-title) 
                          and 
                          not(normalize-space($heading-conf/@generated-frontmatter-title))
                        )
                        and 
                        not(string-join(current-group(), '') = string-join(current-group()//svg:svg/svg:title, ''))">
          <!-- generic front matter nav point before first actual split point -->
          <navPoint id="" class="default" playOrder="0" xmlns="http://www.daisy.org/z3986/2005/ncx/">
            <navLabel>
              <text>
                <xsl:value-of
                  select="(
                                       $heading-conf/@generated-frontmatter-title,
                                       'Frontmatter'
                                      )[1]"
                />
              </text>
            </navLabel>
            <content genid="{(current-group()//@id)[1]}"/>
            <xsl:variable name="next-level" select="(current-group() except .)/@tr-heading-level[not(../@tr-exclude-from-nav)]" as="xs:integer*"/>
            <!--            <xsl:message select="'nl3 level ', $level, ', ', min($next-level)"></xsl:message>-->
            <xsl:if test="min($next-level) = $level">
              <xsl:message>Something's wrong (msg c): same level <xsl:value-of select="$level"/> in <xsl:sequence
                  select="current-group() except ."/></xsl:message>
            </xsl:if>
            <xsl:if test="exists($next-level)">
              <xsl:sequence select="tr:group-for-ncx(current-group() except ., min($next-level), false())"/>
            </xsl:if>
          </navPoint>
        </xsl:when>
      </xsl:choose>
    </xsl:for-each-group>
  </xsl:function>

  <xsl:template match="*[tr:contains-token(@class, ('TOC_same', 'TOC_sub'))]" mode="raw-ncx">
    <navPoint id="" class="default" playOrder="{replace(@tr-generated-id, '^.+?(\d+)$', '$1')}" 
      xmlns="http://www.daisy.org/z3986/2005/ncx/">
      <navLabel>
        <text>
          <xsl:value-of select="(@title, normalize-space(.))[1]"/>
        </text>
      </navLabel>
      <content genid="{(@id, @tr-generated-id)[1]}"/>
    </navPoint>
  </xsl:template>


  <xsl:template match="ncx:navPoint/ncx:content/@genid" mode="play-order">
    <xsl:param name="final-chunks" as="document-node(element(html:chunks))" tunnel="yes"/>
    <xsl:variable name="chunk" select="key('chunk-by-id', ., $final-chunks)" as="element(html:chunk)*"/>
    <xsl:variable name="elt" select="key('by-any-id-available', ., $final-chunks)" as="element(*)*"/>
    <xsl:variable name="id" select="($elt/descendant-or-self::*/@id)[1]" as="attribute(id)?"/>
    <xsl:if test="count($chunk) gt 1">
      <xsl:message>[ERROR] Error in source data: More than one element with id <xsl:value-of select="."/>.
        Only considering the first one.</xsl:message>
    </xsl:if>
    <xsl:choose>
      <xsl:when
        test="count($chunk) eq 0 
                      and (. = '')
                      and count(//ncx:content[@genid = '']) = 1">
        <!-- probably frontmatter chunk -->
        <xsl:variable name="chunks-with-id"
          select="for $g in //ncx:content[not(@genid = '')]/@genid
                                                    return key('chunk-by-id', $g, $final-chunks)"
          as="element(html:chunk)*"/>
        <xsl:variable name="left-chunk" as="element(html:chunk)*"
          select="$final-chunks/*/*[not(some $c in $chunks-with-id satisfies ($c is current()))]"/>
        <xsl:if test="count($left-chunk) eq 1">
          <xsl:attribute name="src" select="replace($left-chunk[1]/@file, '^.+/', $html-prefix)"/>
        </xsl:if>
      </xsl:when>
      <xsl:when test="count($chunk) eq 0 and count($elt) ge 1 and count($id) = 0">
        <xsl:message>[ERROR] Error in intermediate data: Element with generated id <xsl:value-of select="."/> does not have a proper ID.</xsl:message>
      </xsl:when>
      <xsl:when test="count($chunk) eq 0 and count($elt) ge 1">
        <xsl:attribute name="src" select="concat(
                                            replace($elt[1]/ancestor::html:chunk/@file, '^.+/', $html-prefix),
                                            '#',
                                            $id
                                          )"/>
      </xsl:when>
      <xsl:when test="count($chunk) eq 0">
        <xsl:message>[ERROR] Error in source data: There is no element with id <xsl:value-of select="."/>.</xsl:message>
        <xsl:message select="../.."></xsl:message>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="pos" select="index-of($chunk[1]//@id, .)" as="xs:integer+"/>
        <xsl:attribute name="src" select="concat(
                                            replace($chunk[1]/@file, '^.+/', $html-prefix), concat('#', current())
                                          )"
        />
      </xsl:otherwise>
    </xsl:choose>

  </xsl:template>

  <xsl:template match="ncx:navMap/@tr-first-export-file" mode="play-order"/>

  <xsl:template match="ncx:navPoint/@playOrder" mode="play-order">
    <xsl:attribute name="{name()}" select="index-of($playOrder-generated-ids, .)"/>
  </xsl:template>


  <xsl:template match="ncx:navPoint/@id " mode="play-order">
    <xsl:attribute name="{name()}" select="string-join(('i', string(tr:index-of(//ncx:navPoint, ..))), '')"/>
  </xsl:template>

  <xsl:template match="ncx:navPoint/@class" mode="play-order">
    <xsl:attribute name="class" select="string-join(('h', string(count(ancestor::ncx:navPoint))), '')"/>
  </xsl:template>



  <xsl:function name="tr:chunks" as="element(html:chunks)">
    <xsl:param name="split-genids" as="xs:string+"/>
    <chunks common-dir-elimination-regex="{$common-dir-elimination-regex}">
      <xsl:for-each select="(1 to count($split-genids))">
        <xsl:variable name="left-id" select="$split-genids[current()]" as="xs:string"/>
        <xsl:variable name="left" select="key('by-genid', $left-id, $root)"/>
        <xsl:variable name="right-id" select="$split-genids[current() + 1]" as="xs:string?"/>
        <xsl:variable name="right" select="key('by-genid', $right-id, $root)"/>
        <xsl:variable name="local-nodes"
          select="$left union (
                                                   if (exists($right)) 
                                                   then $left/following::* intersect $right/preceding::*
                                                     else $left/following::* 
                                                 )"
          as="node()*"/>
        <xsl:variable name="prelim-export" as="element(html:html)">
          <xsl:apply-templates select="$root" mode="export-chunk-with-surroundings">
            <xsl:with-param name="split-genids" select="$split-genids" tunnel="yes"/>
            <xsl:with-param name="split-genid" select="$left-id" tunnel="yes"/>
            <xsl:with-param name="node-genids" select="for $n in $local-nodes return generate-id($n)" tunnel="yes"/>
            <xsl:with-param name="ancestor-genids" select="for $n in $local-nodes/ancestor::* return generate-id($n)"
              tunnel="yes"/>
          </xsl:apply-templates>
        </xsl:variable><!-- prelim already consists of ancestor sections -->
       <xsl:if test="$split-genids[current()] = 'd26e14588'"><xsl:message select="'###', string-join($prelim-export//*:body/*[1]/@role, '-')"/></xsl:if>
        <xsl:variable name="remove-surrounding-text" as="element(html:html)">
          <xsl:apply-templates select="$prelim-export" mode="remove-surrounding-text"/>
        </xsl:variable>
        <xsl:variable name="body-elts" select="$remove-surrounding-text/html:body/*" as="element(*)*"/>
        <xsl:message>Chunk <xsl:value-of select="tr:export-filename($left-id)"/> (<xsl:value-of select="position()"/> of <xsl:value-of 
          select="last()"/>): <xsl:value-of select="count($body-elts)"/> element<xsl:value-of
          select="if(count($body-elts) gt 1) then 's, starting with ' else ': '"/><xsl:value-of
          select="local-name($body-elts[1])"/></xsl:message>
        <chunk file="{$datadir}/chunks/{tr:export-filename($left-id)}" startnum="{replace($left-id, '^.+?(\d+)$', '$1')}">
          <xsl:copy-of select="key('by-tr-genid', $left-id, $output-file-names)/@tr-linear"/>
          <xsl:sequence select="$remove-surrounding-text"/>
        </chunk>
      </xsl:for-each>
    </chunks>
  </xsl:function>
  
  <xsl:template match="html:body/text()[not(normalize-space())]" priority="2" mode="remove-surrounding-text remove-other-pub-type-content"/>
 
  <xsl:function name="tr:epub-type-pullable" as="xs:boolean">
    <xsl:param name="body" as="element(html:body)"/>
      <xsl:variable name="epub-tokens-from-first-elt" select="tokenize($body/*[@epub:type][1]/@epub:type, '\s+')" as="xs:string*"/>
    <!-- every child must contain the same epub:type(s) that is to be pulled up -->
    <xsl:sequence select="$pull-up-epub-type-to-body = ('true', 'yes') 
                          and 
                          (every $child in $body/* satisfies $child[@epub:type]
                                                                  [some $epub-type-token 
                                                                   in tokenize(@epub:type, '\s+') 
                                                                   satisfies ($epub-type-token[. = $epub-types-for-pulling-to-body 
                                                                                               and
                                                                                               . = $epub-tokens-from-first-elt]
                                                                              )
                                                                   ]
                          )"/>
  </xsl:function>
  
  <xsl:template match="html:body[tr:epub-type-pullable(.)]" priority="2" mode="remove-surrounding-text remove-other-pub-type-content">
    <!-- pull up @epub:type for backmatter, bodymatter, frontmatter to body element-->
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:variable name="all-pullable-tokens" select="for $f in tokenize(*[1][@epub:type]/@epub:type, '\s+') return $f[. = $epub-types-for-pulling-to-body]" as="xs:string+"/>
      <xsl:variable name="new-types" select="for $pt in $all-pullable-tokens return $pt[every $e in current()/* satisfies (. = tokenize($e/@epub:type, '\s+'))]" as="xs:string+"/>
       <xsl:if test="some $s in $new-types satisfies $s[normalize-space()]">
        <xsl:attribute name="epub:type" select="normalize-space(string-join($new-types, ' '))"/>
       </xsl:if>
      <xsl:apply-templates select="node()" mode="#current">
        <xsl:with-param name="pull-up-types" select="$new-types" tunnel="yes" as="xs:string+"/>
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="html:body[tr:epub-type-pullable(.)]/*/@epub:type" priority="2" mode="remove-surrounding-text remove-other-pub-type-content">
     <xsl:param name="pull-up-types" tunnel="yes" as="xs:string+"/>
   <!-- pull up @epub:type for backmatter, bodymatter, frontmatter to body element-->
    <xsl:variable name="new-type" select="tokenize(., '\s+')[not(. = $pull-up-types)]" as="xs:string*"/>
   <xsl:if test="some $s in $new-type satisfies $s[normalize-space()]"><xsl:attribute name="{name()}" select="normalize-space(string-join($new-type, ' '))"/></xsl:if>
  </xsl:template>
  
  <!-- Save this invalid epub-type until the following template will dissolve it -->
  <xsl:template match="html:span/@epub:type[. eq 'dc:identifier']" mode="#all" priority="3">
    <xsl:copy/>
  </xsl:template>

  <xsl:function name="tr:get-dc-identifier" as="element(dc:identifier)?">
    <xsl:sequence select="$epub-config
                            /metadata
                              /(
                                dc:identifier[@format = $final-pub-type], 
                                dc:identifier[not(@format)]
                              )[1]"/>
  </xsl:function>

  <xsl:template match="html:span[(@epub:type, @tr-epub-type)[1] = 'dc:identifier']" mode="remove-surrounding-text remove-other-pub-type-content">
    <xsl:variable name="conf-item" as="element(dc:identifier)?" 
      select="tr:get-dc-identifier()"/>
    <xsl:choose>
      <xsl:when test="$conf-item">
        <xsl:value-of select="$conf-item"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="."/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:param name="newline-regex" select="'(&#x85;|&#x2028;|&#x2029;|&#xd;&#xa;|&#x10fb;|\n)'" as="xs:string"/>

  <!-- remove line breaks in input -->
  <xsl:template match="html:body//html:*[not(local-name() = ('pre', 'script'))]/text()[matches(., $newline-regex)]" mode="remove-surrounding-text remove-other-pub-type-content">
    <xsl:value-of select="replace(., concat('\s*', $newline-regex, '\s*'), '&#x20;')"/>
  </xsl:template>

  <xsl:template match="html:body//html:*[matches(local-name(), '^(h\d|p|div|section|aside|nav|figure|img|footer|blockquote|header|hgroup|ol|ul|li|dd|dt|dl|td|th|table|tfoot|hr)$')][$indent = 'selective']" 
    mode="remove-surrounding-text remove-other-pub-type-content add-selective-indent" priority="2">
    <xsl:text>&#xa;</xsl:text>
    <xsl:sequence select="string-join(for $i in 0 to count(ancestor::*) return '  ', '')"/>
    <xsl:next-match/>
  </xsl:template>

  <xsl:template match="html:body//html:*[matches(local-name(), '^(body|div|section|aside|nav|figure|footer|blockquote|header|hgroup|ol|ul|dl|table|tfoot)$')][$indent = 'selective']"
    mode="remove-surrounding-text remove-other-pub-type-content add-selective-indent">
    <xsl:copy>
      <xsl:apply-templates select="@*, node()" mode="#current"/>
      <xsl:text>&#xa;</xsl:text>
      <xsl:sequence select="string-join(for $i in 0 to count(ancestor::*) return '  ', '')"/>
    </xsl:copy>
  </xsl:template> 


  <!-- remove process attributes starting with tr: -->
  <xsl:template match="@*[starts-with(local-name(), 'tr-')]" mode="resolve-refs"/>

  <!-- remove items that should be removed according to heading-conf: -->
  <xsl:template match="*[generate-id() = $removable-ids]" mode="export-chunk-with-surroundings export-chunk-subtree mobi-htm"/>

  <!-- remove mobipocket-specific content: -->
  <xsl:template match="html:span[@class='mobi']"
    mode="export-chunk-with-surroundings export-chunk-subtree remove-other-pub-type-content">
    <xsl:if test="$final-pub-type eq 'mobi'">
      <xsl:apply-templates mode="#current"/>
    </xsl:if>
  </xsl:template>
  <xsl:template match="html:span[@class=('EPUB','epub')]"
    mode="export-chunk-with-surroundings export-chunk-subtree remove-other-pub-type-content">
    <xsl:if test="$final-pub-type = ('epub', '')">
      <xsl:apply-templates mode="#current"/>
    </xsl:if>
  </xsl:template>

  <!-- Important "upward projection" or slicing template. 
       Using generated ids instead of intersecting the nodes (better performance). -->
  <xsl:template match="*" mode="export-chunk-with-surroundings" priority="2">
    <xsl:param name="split-genids" tunnel="yes" as="xs:string+"/>
    <xsl:param name="split-genid" tunnel="yes" as="xs:string"/>
    <xsl:param name="node-genids" tunnel="yes" as="xs:string+"/>
    <xsl:param name="ancestor-genids" tunnel="yes" as="xs:string+"/>
    <xsl:choose>
      <xsl:when test="generate-id() = $ancestor-genids">
        <xsl:next-match/>
        <!-- identity template in the same mode -->
      </xsl:when>
      <xsl:when test="generate-id() = $node-genids">
        <xsl:apply-templates select="." mode="export-chunk-subtree"/>
      </xsl:when>
      <!-- all other nodes (nor the projection nodes and their subtrees, nor their common ancestors) will be discarded -->
    </xsl:choose>
  </xsl:template>
  
    <!-- make sure that every element referenced in the toc has an id: -->
  <xsl:template match="*[not(@id)]
                        [
                          exists(
                            key('by-tr-genid', generate-id(), $semiflatten)
                              [@tr-heading-level]
                          )
                        ]" 
                mode="export-chunk-with-surroundings export-chunk-subtree">
    <xsl:copy copy-namespaces="no">
      <xsl:attribute name="id" select="generate-id()"/>
      <xsl:apply-templates select="@*, node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <!-- This special ancestor is allowed to carry his brother html:head with him: -->
  <xsl:template match="html:body" mode="export-chunk-with-surroundings" priority="-0.6">
    <xsl:apply-templates select="preceding::html:head"/>
    <xsl:text>&#xa;    </xsl:text>
    <xsl:next-match/>
  </xsl:template>

  <!-- priority has to be lower than default priority for match="*" (which is -0.5), 
       but higher than the catch-all priority specified above -->
  <xsl:template
    match="*[not(@id)][generate-id() = ($partially-ungroup-to-final-split-points/html:body//@tr-generated-id, $partially-ungroup-to-final-split-points/html:body//@tr-dont-split-at-genid)]"
    priority="-0.6" mode="export-chunk-with-surroundings export-chunk-subtree mobi-htm">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="id" select="(@id, generate-id())[1]"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template
    match="*[not(@id)][@epub:type[not(. = ('index-group', 'index-entry', 'index-entry-list', 'index-locator'))]]"
    priority="-0.65" mode="export-chunk-with-surroundings export-chunk-subtree mobi-htm">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:choose>
        <xsl:when test="local-name() = ('a', 'ul', 'dl', 'ol', 'table', 'tbody', 'tr', 'thead', 'tfoot', 'img', 'hgroup', 'pre', 'nav')">
          <xsl:attribute name="id" select="generate-id()"/>
        </xsl:when>
        <xsl:otherwise>
        <xsl:element name="a">
        <xsl:attribute name="id" select="generate-id()"/>
      </xsl:element>
      </xsl:otherwise>
      </xsl:choose>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
    <!-- what about sections? -->
  </xsl:template>
  
  <!-- audio spans will not be dealt with by above templates, but only by the following,
       id-adding template. This implies that no audio span may serve as a splitting candidate. -->
  <xsl:template match="*[@class eq 'au'][not(starts-with(@id, 'au-'))]"
    mode="export-chunk-with-surroundings export-chunk-subtree mobi-htm">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="id" select="generate-id()"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>



  <!-- MODE: resolve-refs
       Will be applied during final export. The links haven't been adjusted in the chunks yet because
       it's easier to look up the target file name after the chunk that the target is in. -->
  <xsl:template match="@href[starts-with(., '#')]" mode="resolve-refs">
    <!-- The linked-to element. If the only child of a body, drop fragment identifier -->
    <xsl:param name="element" as="element(*)?"/>
    <xsl:variable name="this-chunk" select="ancestor::html:chunk" as="element(html:chunk)?"/>
    <xsl:variable name="target-chunk" select="key('chunk-by-id', replace(., '^#', ''), $chunks)" as="element(html:chunk)*"/>
    <xsl:if test="count($target-chunk) gt 1">
      <!-- This may happen for example if a div with the id 'frontmatter' is split. We tacitly assume that the first chunk 
        that contains this id is out target chunk. -->
      <!--<xsl:message>!!!!!!!!!!!!!!!!!!!!!!!! Error in source data: More than one element with id <xsl:value-of
          select="replace(., '^#', '')"/>. Only considering the first one. !!!!!!!!!!!!!!!!!!!!!!!!!!</xsl:message>-->
    </xsl:if>
    <xsl:choose>
      <xsl:when test="count($target-chunk) ge 1">
        <xsl:choose>
          <xsl:when test="($this-chunk is $target-chunk[1]) 
                          and 
                          not(key('by-id', replace(., '^#', ''), $chunks)[ancestor-or-self::html:nav[contains(@epub:type,'toc')]])">
            <!-- it is a problem if the nav is linked within the nav without its filename: href="nav.xhtml#toc" is ok href="#toc" isn't -->
            <xsl:copy-of select="."/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="new-href" as="xs:string" select="replace($target-chunk[1]/@file, '^.+/', '')"/>
            <xsl:choose>
              <xsl:when test="$element/self::html:body">
                <!-- no fragment identifier if it is the body -->
                <xsl:attribute name="href" select="$new-href"/>
              </xsl:when>
              <xsl:when test="$element is $element/parent::html:body/*[1]">
                <!-- no fragment identifier if it is the first (or only) element -->
                <xsl:attribute name="href" select="$new-href"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="href" select="concat($new-href, .)"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:message>Cannot find target for href=<xsl:value-of select="."/>
        </xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="html:link/@href[matches(., '^(file|https?):')]
                      |html:img/@src[matches(., '^(file|https?):')]
                      |svg:image/@xlink:href[matches(., '^(file|https?):')]
                      |html:video/@src[matches(., '^(file|https?):')]
                      |html:audio/@src[matches(., '^(file|https?):')]
                      |html:source/@src[matches(., '^(file|https?):')]
                      |mml:math/@altimg[matches(., '^(file|https?):')]"
    mode="resolve-refs" priority="2">
    <xsl:variable name="hopefully-relative" as="xs:string" select="replace(., $common-dir-elimination-regex, '')"/>
    <xsl:choose>
      <xsl:when test="matches($hopefully-relative, '^(https?|file)')">
        <!-- radical path removal as a last resort – don’t know whether this pure file name is in the content.opf like this: -->
        <xsl:attribute name="{name()}" select="replace(., '^.+/', if (normalize-space($html-prefix)) then '../' else '')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:attribute name="{name()}" select="concat(if (normalize-space($html-prefix)) then '../' else '', $hopefully-relative)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- relative links -->
  <xsl:template match="html:link/@href[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |html:img/@src[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |svg:image/@xlink:href[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |html:video/@src[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |html:audio/@src[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |html:source/@src[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |mml:math/@altimg[normalize-space($html-prefix)][not(matches(., '^#'))]"
    mode="resolve-refs">
    <xsl:attribute name="{name()}" select="concat('../', .)"/>
  </xsl:template>
  
  <xsl:key match="*[@aria-label]" use="@aria-label" name="epub:elts-with-aria-label"/>
    

  <xsl:template match="@aria-label[normalize-space()]" mode="resolve-refs">
    <xsl:attribute name="{name()}" select="if (count(key('epub:elts-with-aria-label', ., root(.))) gt 1) 
                                           then string-join((., count(preceding::*[@aria-label]/@aria-label = current())), ' ')
                                           else ."/>
  </xsl:template>

  <xsl:template match="@xml:base" mode="resolve-refs"/>

  <!-- should be [not(html:nav[@epub:type = 'toc'])] but people are using other stuff in EPUB2 production -->
  <xsl:template match="html:body[count(*/@epub:type) = 1][*[1][@epub:type][not(self::html:section|self::html:div)]][not(*[@epub:type = 'toc'])]" mode="resolve-refs">
    <!-- If there is only one element with an epub:type, and if it is the first (incl.: only) child
      of body, assume that its epub:type applies to the whole chunk and merge its epub:type with
    the body’s epub:type -->
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="epub:type" select="distinct-values((@epub:type, */@epub:type))"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  
  <!-- should be self::html:nav[@epub:type = 'toc'] but people are using other stuff in EPUB2 production -->
  <xsl:template match="html:body[count(*/@epub:type) = 1][*[1][@epub:type][not(self::html:section|self::html:div)]]/*[@epub:type][not(self::*[@epub:type = 'toc'])]" mode="resolve-refs">
    <xsl:copy>
      <xsl:apply-templates select="@* except @epub:type, node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  

  <xsl:function name="tr:abbreviate-for-toc" as="xs:string?">
    <xsl:param name="content" as="xs:string?"/>
    <xsl:variable name="tokenized" as="xs:string*" select="tokenize($content, '[\s\p{Zs}]+')"/>
    <xsl:variable name="normalized" as="xs:string" select="replace(
                                                             string-join(
                                                               $tokenized[position() = (1 to 8)],
                                                               ' '
                                                             ),
                                                             '[\s&#xa0;]*[.,:;\?!–—…]$',
                                                             ''
                                                           )"/>
    <xsl:choose>
      <xsl:when test="count($tokenized) le 8">
        <xsl:sequence select="$normalized"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="concat($normalized, '&#xa0;…')"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <xsl:function name="tr:export-filename" as="xs:string">
    <xsl:param name="split-genid" as="xs:string?"/>
    <xsl:if test="empty($split-genid)">
      <xsl:message terminate="no"> Something’s wrong: should have a generated ID in every chunk </xsl:message>
    </xsl:if>
    <xsl:sequence select="distinct-values(key('by-tr-genid', $split-genid, $output-file-names)/@tr-output-name)"/>
  </xsl:function>

  <xsl:function name="tr:custom-pad" as="xs:string">
    <xsl:param name="generated-id" as="xs:string"/>
    <xsl:param name="final-length" as="xs:integer"/>
    <xsl:sequence select="string-join(
      (for $i in 1 to ($final-length - string-length(replace($generated-id, '^.*?([0-9]+)$', '$1'))) return '0', 
        replace($generated-id, '^.*?([0-9]+)$', '$1')), '')"/>
  </xsl:function>

  <xsl:function name="tr:index-of" as="xs:integer*">
    <xsl:param name="nodes" as="node()*"/>
    <xsl:param name="node" as="node()"/>
    <xsl:sequence select="index-of(for $n in $nodes return generate-id($n), generate-id($node))"/>
  </xsl:function>

  <xsl:function name="tr:contains-token" as="xs:boolean">
    <xsl:param name="string" as="xs:string?"/>
    <xsl:param name="tokens" as="xs:string*"/>
    <xsl:sequence select="if ($string) then tokenize($string, '\s+') = $tokens else false()"/>
  </xsl:function>

</xsl:stylesheet>
