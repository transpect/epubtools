<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:tr="http://transpect.io" 
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:opf="http://www.idpf.org/2007/opf" 
  xmlns:epub="http://www.idpf.org/2007/ops"
  xmlns:ncx="http://www.daisy.org/z3986/2005/ncx/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:svg="http://www.w3.org/2000/svg" 
  xmlns:xlink="http://www.w3.org/1999/xlink" 
  xmlns:dtb="http://www.daisy.org/z3986/2005/dtb/"
  xmlns:smil="http://www.w3.org/ns/SMIL"
  xmlns:mml="http://www.w3.org/1998/Math/MathML"
  xmlns="http://www.w3.org/1999/xhtml"
  version="2.0"
  exclude-result-prefixes="html opf xs ncx tr smil dc epub svg dtb mml">

	<!-- create references between smil and html chunks -->
	<xsl:include href="media-overlay.xsl"/>

  <xsl:output method="text" />

  <xsl:output name="debug" method="xml" encoding="UTF-8" doctype-public="-//W3C//DTD XHTML 1.1//EN"
    doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" indent="yes"/>
  <!-- Actual doctype (if any) will be set by the p:store serialization options in XProc -->  
  <xsl:output name="export" method="xhtml" encoding="UTF-8" doctype-public="-//W3C//DTD XHTML 1.1//EN"
    doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd" indent="no"/>

  <xsl:output name="xml" method="xml" encoding="UTF-8" indent="yes"/>

  <xsl:output name="text" method="text" encoding="UTF-8"/>

  <!-- Sample invocation:
       only through XProc because we utilize the default collection(). See ../xpl/html-splitter.xpl 

     Calabash seems to suppress some XSLT errors, for instance when a stylesheet is looping.
     Therefore it might be necessary to replace collection()[…] with document(…) in this XSL
     and run saxon from the command line. See html-splitter.xpl for an example.
       -->

  <xsl:param name="datadir" select="resolve-uri('.', base-uri(/*))" as="xs:string"/>
  <xsl:param name="heading-conf-uri" as="xs:string?"/>
  <xsl:param name="meta-uri" as="xs:string?"/>
  <!-- which package format we want to create later? (values: 'epub' or 'mobi'; empty string: 'epub')-->
  <xsl:param name="final-pub-type" select="''" as="xs:string"/>
  <!-- indent: true|false|selective
       true and false are being dealt with by XPRoc’s p:store serialization options.
       If indent="selective", p:store will store non-indented, and the indent before paragraphs etc.
       must be generated by this stylesheet, in the mode remove-surrounding-text.-->
  <xsl:param name="indent" select="'true'" as="xs:string"/>
  <xsl:param name="html-subdir-name" select="''" as="xs:string"/>
  <xsl:variable name="html-prefix" select="if (normalize-space($html-subdir-name)) then concat($html-subdir-name, '/') else ''"/>
  <!-- debug params -->
  <xsl:param name="debug" select="'no'"/>
  <xsl:param name="debug-dir-uri" select="'debug'"/>

  <xsl:variable name="common-dir-elimination-regex" as="xs:string"
    select="replace($datadir, '/+', '/+')"/>
  <xsl:variable name="orig-filename" select="replace(base-uri(/*), '^.*/', '')"/>
  <xsl:variable name="raw-smil-filename" select="replace(base-uri(/*), '[.]\w+$', '.raw.smil')"/>
  <xsl:variable name="epub-config" select="collection()/epub-config" as="element(epub-config)"/>
  <!-- uncomment this for standalone Saxon operation: -->
  <!--<xsl:variable name="epub-config" select="document($meta-uri)/epub-config" as="element(epub-config)"/>-->
  <!-- If heading conf is submitted in a separate file, it will have precedence. It may be submitted as /epub-config/hierarchy -->
  <xsl:variable name="heading-conf"
    select="(collection()/hierarchy, collection()/epub-config/hierarchy)[1]" as="element(hierarchy)"/>
    <!-- uncomment this for standalone Saxon operation: -->
  <!--<xsl:variable name="heading-conf" select="$epub-config/hierarchy" as="element(hierarchy)"/>-->
  <xsl:variable name="metadata" select="$epub-config/metadata" as="element(metadata)"/>

  <!-- CATCH-ALL IDENTITY TEMPLATE -->
  <xsl:template match="node()|@*" mode="#all" priority="-0.9">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:apply-templates select="*|text()" mode="#current"/>
    </xsl:copy>
  </xsl:template>


  <!-- KEYS and GLOBAL VARIABLES -->
  <xsl:variable name="root" select="/" as="document-node(element(html:html))"/>

  <!-- input file name / URL without path and extension: --> 
  <xsl:param name="basename" as="xs:string" select="replace(base-uri(/*), '^.+/', '')"/>
  <xsl:variable name="splatter-debug-dir-uri" as="xs:string"
    select="concat($debug-dir-uri, '/epubtools/html-splitter/', $basename)"/>
  

  <xsl:key name="by-signature" match="*" use="tr:signature-from-doc(.)"/>
  <xsl:key name="by-genid" match="*" use="generate-id()"/>
  <xsl:key name="by-tr-genid" match="*" use="@tr-generated-id"/>
  <xsl:key name="by-id" match="*[@id]" use="@id"/>
  <xsl:key name="by-any-id-available" match="*[@id | @tr-generated-id]" use="@id, @tr-generated-id"/>
  <xsl:key name="chunk-by-id" match="html:chunk" use=".//@id[not(. = '')]"/>

  <xsl:variable name="candidates" select="key('by-signature', for $h in $heading-conf/* return tr:signature-from-conf($h))"
    as="element(*)*"/>
  <xsl:variable name="candidate-ids" select="for $n in $candidates return generate-id($n)" as="xs:string*"/>
  <xsl:variable name="removable-ids"
    select="for $r in $candidates[tr:signature-from-doc(.) = (for $h in $heading-conf/*[@remove eq 'yes'] 
                                               return tr:signature-from-conf($h))] return generate-id($r)"
    as="xs:string*"/>


  <!-- PROCESSING PIPELINE using global variables which hold transformed trees: -->
  <xsl:variable name="semiflatten" as="document-node(element(html:html))">
    <xsl:document>
      <xsl:apply-templates select="/" mode="semiflatten"/>  
    </xsl:document>
  </xsl:variable>
  <xsl:variable name="fullflatten" as="element(html:html)">
    <xsl:apply-templates select="$semiflatten" mode="fullflatten"/>
  </xsl:variable>
  <xsl:variable name="group-starting-with-split-candidates" as="element(html:html)">
    <xsl:apply-templates select="$semiflatten" mode="group-starting-with-split-candidates"/>
  </xsl:variable>
  <xsl:variable name="respect-hierarchy-among-conditional-split-candidates" as="element(html:html)">
    <xsl:apply-templates select="$group-starting-with-split-candidates"
      mode="respect-hierarchy-among-conditional-split-candidates"/>
  </xsl:variable>
  <xsl:variable name="partially-ungroup-to-final-split-points" as="element(html:html)">
    <xsl:apply-templates select="$respect-hierarchy-among-conditional-split-candidates"
      mode="partially-ungroup-to-final-split-points"/>
  </xsl:variable>
  <xsl:variable name="output-file-names" as="document-node(element(html:html))">
    <xsl:document>
      <xsl:apply-templates select="$partially-ungroup-to-final-split-points" mode="output-file-names"/>
    </xsl:document>
  </xsl:variable>
  <!-- $chunks has to be a document node because it will serve as 3rd argument to xsl:key() -->
  <xsl:variable name="chunks" as="document-node(element(html:chunks))">
    <xsl:document>
      <xsl:sequence 
        select="tr:chunks($output-file-names/html:html/html:body//@tr-generated-id
                          [empty(ancestor::html:content)]
                          [
                            (: https://redmine.le-tex.de/issues/6590 also 6624 :)
                            not(./ancestor-or-self::*/@tr-generated-id = ../ancestor::*/(@tr-dont-split-at-genid (:| @tr-generated-id:)))
                          ])"/>
    </xsl:document>
  </xsl:variable>
  <xsl:variable name="raw-ncx" as="document-node(element(ncx:navMap))">
    <xsl:document>
      <xsl:apply-templates select="$fullflatten" mode="raw-ncx"/>
    </xsl:document>
  </xsl:variable>

  <xsl:variable name="epub3-landmark-types" as="xs:string+" select="('acknowledgments',
                                                                     'backmatter', 
                                                                     'bibliography', 
                                                                     'bodymatter', 
                                                                     'copyright-page',
                                                                     'cover', 
                                                                     'frontmatter', 
                                                                     'glossary', 
                                                                     'index', 
                                                                     'loi', 
                                                                     'lot', 
                                                                     'preface', 
                                                                     'titlepage', 
                                                                     'toc' 
                                                                     )"/>
  <xsl:variable name="landmark-types" as="xs:string+" 
    select="if (normalize-space($epub-config/types/type[@name = 'landmarks']/@types))
            then tokenize($epub-config/types/type[@name = 'landmarks']/@types, '\s+')
            else $epub3-landmark-types"/>

  <xsl:template name="main">
    <xsl:if test="not($heading-conf)">
      <xsl:message terminate="yes">Cannot access the heading configuration XML file. A URI to a proper heading conf must be
        given using heading-conf-uri=... Please consider that relative paths are relative to the XSL stylesheet. When invoking
        this via XProc, the configuration may be given as the second document on this step’s source port. </xsl:message>
    </xsl:if>

    <xsl:if test="$debug eq 'yes'">
      <xsl:result-document href="{$splatter-debug-dir-uri}/03.semiflatten.xhtml" format="debug">
        <debug><xsl:sequence select="$semiflatten"/></debug>
      </xsl:result-document>
      <xsl:result-document href="{$splatter-debug-dir-uri}/03a.fullflatten.xhtml" format="debug">
        <debug><xsl:sequence select="$fullflatten"/></debug>
      </xsl:result-document>
      <xsl:result-document href="{$splatter-debug-dir-uri}/04.group-starting-with-split-candidates.xhtml" format="debug">
        <debug><xsl:sequence select="$group-starting-with-split-candidates"/></debug>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/05.respect-hierarchy-among-conditional-split-candidates.xhtml"
        format="debug">
        <debug><xsl:sequence select="$respect-hierarchy-among-conditional-split-candidates"/></debug>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/06.partially-ungroup-to-final-split-points.xhtml" format="debug">
        <debug><xsl:sequence select="$partially-ungroup-to-final-split-points"/></debug>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/07.output-file-names.xhtml" format="debug">
        <debug><xsl:sequence select="$output-file-names"/></debug>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/08.chunks.xhtml" format="debug">
        <xsl:apply-templates select="$chunks"/>
      </xsl:result-document>

      <xsl:result-document href="{$splatter-debug-dir-uri}/10.raw-ncx.xml" format="debug">
        <xsl:apply-templates select="$raw-ncx"/>
      </xsl:result-document>
    </xsl:if>

    <!-- remove other content (i.e. mobi when final publication format is epub) -->
    <xsl:variable name="strip-other-content">
      <xsl:apply-templates select="$root" mode="remove-other-pub-type-content"/>
    </xsl:variable>
    <xsl:variable name="chunks-text"
        select="replace(string-join($chunks/html:chunks/html:chunk/html:html/html:body, ''), '[\s\p{Zs}]+', '&#xa;')" as="xs:string"/>
    <xsl:variable name="orig-text" select="replace($strip-other-content/html:html/html:body, '[\s\p{Zs}]+', '&#xa;')" as="xs:string"/>
    <xsl:if test="$chunks-text ne $orig-text">
      <xsl:message>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Chunked
        text (modulo whitespace) is not identical to original text! Please diff <xsl:value-of select="$splatter-debug-dir-uri"
        />/chunks.txt and <xsl:value-of select="$splatter-debug-dir-uri"/>/orig.txt. This problem may arise when there is
        non-whitespace text on the same level as splitting elements, or when there was text within an element that has been
        removed after splitting unconditionally at said element. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! </xsl:message>
      <!-- Even though these are going to be text files, we have to supply XML documents
          and store them as text in the xpl according to their file extensions.
          Otherwise Calabash will silently break. -->
      <xsl:result-document href="{$splatter-debug-dir-uri}/chunks.txt" format="xml">
        <doc>
          <xsl:value-of select="$chunks-text"/>
        </doc>
      </xsl:result-document>
      <xsl:result-document href="{$splatter-debug-dir-uri}/orig.txt" format="xml" encoding="utf8">
        <doc>
          <xsl:value-of select="$orig-text"/>
        </doc>
      </xsl:result-document>
    </xsl:if>

    <!--<xsl:variable name="landmarks" as="element(*)*"
      select="$chunks/html:chunks/html:chunk//*[@id | @tr-generated-id][tr:contains-token(@epub:type, $landmark-types)]"/>-->

    <xsl:variable name="landmarks" as="element(*)*">
      <xsl:for-each-group select="$chunks/html:chunks/html:chunk//*[@id | @tr-generated-id]
                                                                   [tr:contains-token(@epub:type, $landmark-types)]"
                          group-by="@epub:type">
        <!-- index, preface, … may occur multiple times. Use only the first item of a kind 
          (also in order to avoid kindlegen warnings). --> 
        <xsl:sequence select="."/>
      </xsl:for-each-group>
    </xsl:variable>

    <!-- write page-map.xml -->
    <xsl:if test="($epub-config/@page-map-xml, 'true')[1] ne 'false' and $final-pub-type ne 'EPUB3'">
      <xsl:apply-templates select="$pgl" mode="page-map"/>
    </xsl:if>

    <xsl:variable name="toc-ncx" as="element(ncx:ncx)">
      <xsl:call-template name="ncx">
        <xsl:with-param name="final-chunks" select="$chunks" tunnel="yes"/>
      </xsl:call-template>
    </xsl:variable>
    <!-- write toc NCX for EPUB2
      and EPUB3: http://www.idpf.org/epub/301/spec/epub-publications.html#ncx-superseded
    -->
    <xsl:result-document href="{$datadir}/chunks/toc.ncx" format="xml">
      <xsl:choose>
        <xsl:when test="$indent = 'selective'">
          <xsl:apply-templates select="$toc-ncx" mode="add-selective-indent"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$toc-ncx"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:result-document>

    <!-- write HTML toc nav for EPUB3 (will also be created for EPUB2 etc. but has to be discarded before storing to disk.
      Reason: being able to generate a guide element in the content.opf) -->
    <!-- when *[@epub:type] with value 'toc' is present in content documents, the landmarks nav is created there too -->
    <xsl:if test="not($chunks//*[tr:contains-token(@epub:type, 'toc')])">
      <xsl:variable name="toc-nav">
        <xsl:call-template name="toc-nav">
          <xsl:with-param name="toc-ncx" select="$toc-ncx"/>
          <xsl:with-param name="landmarks" select="$landmarks"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:result-document href="{$datadir}/chunks/nav.xhtml" format="export">
        <xsl:choose>
          <xsl:when test="$indent = 'selective'">
            <xsl:apply-templates select="$toc-nav" mode="add-selective-indent"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="$toc-nav"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:result-document>
    </xsl:if>

    <!-- write chunks -->
    <xsl:for-each select="$chunks/html:chunks/html:chunk">
      <xsl:result-document href="{@file}" format="export">
        <xsl:apply-templates select="html:html" mode="resolve-refs">
          <xsl:with-param name="pos" select="position()" tunnel="yes"/>
          <xsl:with-param name="landmarks" select="$landmarks" tunnel="yes"/>
        </xsl:apply-templates>
      </xsl:result-document>
    </xsl:for-each>
    
    <xsl:if test="doc-available($raw-smil-filename)">
      <xsl:call-template name="smil">
        <xsl:with-param name="smil" select="document($raw-smil-filename)/smil:smil"/>
        <xsl:with-param name="text" select="$chunks"/>
        <xsl:with-param name="datadir" select="$datadir"/>
        <xsl:with-param name="html-subdir-name" select="$html-subdir-name"/>
      </xsl:call-template>
    </xsl:if>

    <xsl:sequence select="$chunks"/>

  </xsl:template>

  <xsl:template match="html:meta[@http-equiv]">
    <xsl:choose>
      <xsl:when test="$final-pub-type eq 'EPUB3' and matches(@content, 'charset=')">
        <xsl:variable name="charset" select="replace(@content, '^.*charset=(.*)$', '$1')"/>
        <meta charset="{$charset}"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:copy>
          <xsl:apply-templates select="@*"/>
        </xsl:copy>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="add-selective-indent page-map" priority="2"
    match="ncx:ncx//* | html:html/* | html:pgl/html:page">
    <xsl:text>&#xa;</xsl:text>
    <xsl:sequence select="string-join(for $i in 0 to count(ancestor::*) return '  ', '')"/>
    <xsl:next-match/>
  </xsl:template>

  <xsl:template match="ncx:*[not(self::ncx:text or self::ncx:content or self::ncx:meta)]" mode="add-selective-indent">
    <xsl:copy>
      <xsl:apply-templates select="@*, node()" mode="#current"/>
      <xsl:text>&#xa;</xsl:text>
      <xsl:sequence select="string-join(for $i in 0 to count(ancestor::*) return '  ', '')"/>
    </xsl:copy>
  </xsl:template>

  <!-- MODE: SEMIFLATTEN
       Dissolve divs which contain more than a single heading (important for later grouping) -->
  <xsl:variable name="tr:dissolvable-for-semiflatten" as="element(*)*"
    select="//*[local-name() = ('aside', 'div', 'nav', 'header', 'section', 'table', 'tbody', 'tr', 'td', 'th')]"/>

  <xsl:template
    match="*[exists(. intersect $tr:dissolvable-for-semiflatten)][
                         (count(.//* intersect $candidates) gt 1)
                         and not(
                           generate-id(.) = $candidate-ids
                           and $heading-conf/unconditional-split[tr:signature-from-conf(.) = tr:signature-from-doc(current())]  
                         )
                       ]"
    mode="semiflatten">
    <xsl:processing-instruction name="origin" select="'A'"/>
    <xsl:apply-templates mode="#current"/>
  </xsl:template>

  <!-- match a no split element (i.e. cover div) before very first split candidate -->
  <xsl:template
    match="*[. is $tr:dissolvable-for-semiflatten[1]]
            [
              count(.//* intersect $candidates) eq 0
              and not(
                generate-id(.) = $candidate-ids
              )
            ]" 
    mode="semiflatten">
    <xsl:copy>
      <xsl:attribute name="origin" select="'B'"/>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="tr-splitting-priority" select="'unconditional'"/>
      <xsl:if test="not(@id)">
        <xsl:attribute name="id" select="generate-id()"/>
        <xsl:attribute name="tr-source-element-without-id-attribute" select="'true'"/>
      </xsl:if>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <xsl:apply-templates select="node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  
  <xsl:template
    match="*[empty(@id)]
            [tr:contains-token(@class, ('TOC_same', 'TOC_sub'))]" 
    mode="semiflatten export-chunk-subtree export-chunk-with-surroundings">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="id" select="generate-id()"/>
      <xsl:attribute name="tr-source-element-without-id-attribute" select="'true'"/>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="*[exists(. intersect $tr:dissolvable-for-semiflatten)][count(.//* intersect $candidates) eq 1]
                        [not(ancestor::*[exists(. intersect $tr:dissolvable-for-semiflatten)][count(.//* intersect $candidates) eq 1])]" mode="semiflatten"
    priority="2">
    <xsl:param name="split-for" as="xs:string?"/>
    <xsl:variable name="contained-candidate" select=".//* intersect $candidates" as="element(*)"/>
    <xsl:copy copy-namespaces="no">
      <xsl:attribute name="origin" select="'C'"/>
      <xsl:copy-of select="@*"/>
      <xsl:attribute name="tr-split-for" select="generate-id($contained-candidate)"/>
      <xsl:apply-templates select="($contained-candidate, .)/@epub:type" mode="#current"/>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <xsl:variable name="dont-split" as="xs:boolean" 
        select="tr:contains-token(string-join((current(), $contained-candidate)/@class, ' '), '_nosplit')"/>
      <xsl:variable name="corresponding-conf-items-for-current" as="element()*"
        select="$heading-conf/*[tr:signature-from-conf(.) = tr:signature-from-doc(current())]"/>
      <xsl:variable name="corresponding-conf-items-for-candidates" as="element()*"
        select="$heading-conf/*[tr:signature-from-conf(.) = tr:signature-from-doc($contained-candidate)]"/>
      <xsl:variable name="corresponding-conf-items"
        select="$corresponding-conf-items-for-current
                union
                $corresponding-conf-items-for-candidates"
        as="element()+"/>
      <xsl:for-each select="$corresponding-conf-items/@max-text-length">
        <xsl:attribute name="tr-max-text-length" select="."/>
      </xsl:for-each>
      <xsl:attribute name="tr-splitting-priority">
        <xsl:choose>
          <!-- unconditional split on a splitting delegate div beats _nosplit on its contained heading -->
          <xsl:when test="tr:contains-token($contained-candidate/@class, '_nosplit')
                          and $corresponding-conf-items-for-current/name() = 'unconditional-split'
                          and not(tr:contains-token(@class, '_nosplit'))">
            <xsl:sequence select="'unconditional'"/>
          </xsl:when>
          <xsl:when test="tr:contains-token(current()/@class, '_nosplit')">
            <xsl:sequence select="'conditional'"/>
          </xsl:when>
          <xsl:when test="$corresponding-conf-items/name() = 'unconditional-split'">
            <xsl:sequence select="'unconditional'"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:sequence select="'conditional'"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <xsl:if test="$corresponding-conf-items/@linear = 'no'">
        <xsl:attribute name="tr-linear" select="'no'"/>
      </xsl:if>
      <xsl:if test="$corresponding-conf-items/name() = 'heading'">
        <xsl:attribute name="tr-heading-level"
          select="( $corresponding-conf-items[name() = 'heading']/@level,
                   tr:index-of($heading-conf/heading, $corresponding-conf-items[name() = 'heading']) )[1]"
        />
      </xsl:if>
      <xsl:if test="$corresponding-conf-items/name() = 'conditional-split'">
        <xsl:attribute name="tr-heading-level"
          select="( $corresponding-conf-items[name() = 'conditional-split'][1]/@level,
                   100 + tr:index-of($heading-conf/conditional-split, $corresponding-conf-items[name() = 'conditional-split'][1]) )[1]"
        /><!-- 100 is important for a distinction, see below (we could have used other element names, but that’s the way
          we implemented it) -->
        <xsl:if test="$corresponding-conf-items[name() = 'conditional-split'][1]/@nav = 'no'">
          <xsl:attribute name="tr-exclude-from-nav" select="'tr-exclude-from-nav'"/>  
        </xsl:if>
      </xsl:if>
      <xsl:apply-templates mode="#current">
        <xsl:with-param name="split-for" select="($split-for, generate-id())[1]"/>
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>

  <!-- lower priority than previous template. This means that an unconditional-split div
       won't be dealt with in this template if it contains exactly one heading or 
       unconditional-split in its subtree. -->
  <xsl:template match="*[generate-id(.) = $candidate-ids]" mode="semiflatten">
    <xsl:param name="split-for" as="xs:string?"/>
    <xsl:copy copy-namespaces="no">
      <xsl:attribute name="origin" select="'D'"/>
      <xsl:copy-of select="@*"/>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <!-- Just in case that there is no epub:type here but on a dissolved ancestor, we transform the 
        ancestor’s epub:type, too. -->
      <xsl:apply-templates select="ancestor::*[@epub:type][1]/@epub:type, @epub:type" mode="#current"/>
      <xsl:if test="not(@id)">
        <xsl:attribute name="id" select="generate-id()"/>
        <xsl:attribute name="tr-source-element-without-id-attribute" select="'true'"/>
      </xsl:if>
      <xsl:variable name="corresponding-conf-items" as="element()+">
        <xsl:for-each-group select="$heading-conf/*[tr:signature-from-conf(.) = tr:signature-from-doc(current())]"
          group-by="name()">
          <!-- For each group (there may be two: unconditional-split and heading) return the first
               item after they've been sortet by hash length. This is the most specific element of each category.
               This approach seems a bit clumsy. -->
          <xsl:variable name="conf-signatures" as="xs:string+">
            <xsl:perform-sort select="for $cg in current-group() return tr:signature-from-conf(.)">
              <xsl:sort select="string-length(.)" order="descending"/>
            </xsl:perform-sort>
          </xsl:variable>
          <xsl:sequence select="current-group()[tr:signature-from-conf(.) = $conf-signatures[1]]"/>
        </xsl:for-each-group>
      </xsl:variable>
      <xsl:if test="$corresponding-conf-items/name() = 'heading'">
        <xsl:attribute name="tr-heading-level"
          select="( $corresponding-conf-items[name() = 'heading']/@level,
                   tr:index-of($heading-conf/heading, $corresponding-conf-items[name() = 'heading']) )[1]"
        />
      </xsl:if>
      <xsl:if test="$corresponding-conf-items/name() = 'conditional-split'">
        <xsl:attribute name="tr-heading-level"
          select="( $corresponding-conf-items[name() = 'conditional-split'][1]/@level,
                   100 + tr:index-of($heading-conf/conditional-split, $corresponding-conf-items[name() = 'conditional-split'][1]) )[1]"/>
        <xsl:if test="$corresponding-conf-items[name() = 'conditional-split'][1]/@nav = 'no'">
          <xsl:attribute name="tr-exclude-from-nav" select="'tr-exclude-from-nav'"/>  
        </xsl:if>
      </xsl:if>
      <xsl:for-each select="$corresponding-conf-items/@max-text-length">
        <xsl:attribute name="tr-max-text-length" select="."/>
      </xsl:for-each>
      <xsl:choose>
        <xsl:when test="$split-for">
          <xsl:attribute name="tr-split-delegation-to" select="$split-for"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:attribute name="tr-splitting-priority"
            select="if ($corresponding-conf-items/name() = 'unconditional-split' and not(tr:contains-token(current()/@class, '_nosplit'))) 
                    then 'unconditional' else 'conditional'"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="$corresponding-conf-items/@remove eq 'yes'">
        <xsl:attribute name="tr-remove" select="'yes'"/>
      </xsl:if>
      <xsl:if test="$corresponding-conf-items/@linear = 'no'">
        <xsl:attribute name="tr-linear" select="'no'"/>
      </xsl:if>
<!--      <xsl:if test="not(descendant::*[generate-id(.) = $candidate-ids])">-->
        <xsl:apply-templates mode="#current"/>
      <!--</xsl:if>-->
    </xsl:copy>
    <!--<xsl:if test="descendant::*[generate-id(.) = $candidate-ids]">
      <xsl:apply-templates mode="#current"/>
    </xsl:if>-->
  </xsl:template>

  <xsl:template match="*" mode="semiflatten">
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates select="@epub:type" mode="#current"/>
      <xsl:attribute name="tr-generated-id" select="generate-id()"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="@epub:type" mode="semiflatten" priority="2">
    <xsl:copy/>
    <xsl:variable name="tokenized" select="tokenize(., '\s+')" as="xs:string+"/>
    <xsl:variable name="landmarks" select="$tokenized[. = $epub3-landmark-types]" as="xs:string*"/>
    <xsl:variable name="non-landmarks" select="$tokenized[not(. = $epub3-landmark-types)]" as="xs:string*"/>
    <xsl:attribute name="tr-epub-type" select="if (exists($non-landmarks)) then $non-landmarks else $landmarks"/>
    <xsl:if test="exists($non-landmarks) and exists($landmarks)">
      <xsl:attribute name="tr-epub-extra-landmark-type" select="$landmarks"/>
    </xsl:if>
  </xsl:template>

  <xsl:template match="/*" mode="semiflatten">
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@*"/>
      <xsl:attribute name="tr-candidate-ids" select="$candidate-ids"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="@shape" mode="#all" priority="10"/>

  <!-- A signature is a footprint or a hash value for a specific kind of element. It may be calculated 
       for configuration selectors as well as for content items. By means of this signature, configuration
       options may be applied to the content items they pertain to. -->
  <xsl:function name="tr:signature-from-conf" as="xs:string+">
    <xsl:param name="conf-item" as="element()"/>
    <xsl:if test="not($conf-item/@attr = ('class', 'epub:type', 'id'))">
      <xsl:choose>
        <!-- the current specification is generic, and there is another specification for the same element, but with a specific class: -->
        <xsl:when
          test="some $otheritem in ($conf-item/preceding-sibling::* union $conf-item/following-sibling::*)[name() eq $conf-item/name()]
                    [if ($conf-item/@elt) then @elt = $conf-item/@elt else true()] 
                  satisfies ($otheritem/@attr = ('class', 'epub:type', 'id'))"/>
        <xsl:otherwise>
          <!-- the current item is generic, and there is no other specification for the same element, but with a specific class: -->
          <xsl:sequence select="$conf-item/@elt"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <!-- For a specification that pertains to a specific class, issue the fully qualified specification in any case:  -->
    <xsl:sequence select="string-join((if ($conf-item/@elt) then concat('elt=', $conf-item/@elt) else (), $conf-item[@attr = ('class', 'epub:type', 'id')]/(@attr, @attval)), '__')"/>
  </xsl:function>

  <xsl:function name="tr:signature-from-doc" as="xs:string+">
    <xsl:param name="elt" as="element()"/>
    <xsl:for-each select="$elt/(@class, @epub:type, @id)">
      <xsl:variable name="att" select="." as="attribute()"/>
      <xsl:for-each select="tokenize(., '\s+')">
        <xsl:sequence select="string-join((name($att), .), '__')"/>
        <xsl:sequence select="string-join((concat('elt=', local-name($elt)), name($att), .), '__')"/>
      </xsl:for-each>
    </xsl:for-each>
    <xsl:sequence select="concat('elt=', local-name($elt))"/>
  </xsl:function>

  <!-- MODE: GROUP-STARTING-WITH-SPLIT-CANDIDATES
       and 
       MODE: RESPECT-HIERARCHY-AMONG-CONDITIONAL-SPLIT-CANDIDATES
       After flattening most of the divs, the headings are on the same level.
       They will be grouped to nested headings. On the topmost level, grouping will
       take place according to unconditional-split. This means that
       the grouping will not necessarily reflect the document's hierarchy exactly. 
       In the first of the two passes, only unconditional-splits and headings will be discerned. 
       In the second one, in addition to further nesting the
       conditional hierarchy, the split content will be subsplit if
       its length exceeds the configured max chunk length.
       The purpose of nested grouping is: to be able to carry out size calculations
       more easily.
       Content that isn't needed for size calculations any more will be discarded. -->
  <xsl:template match="html:body" mode="group-starting-with-split-candidates">
    <xsl:copy copy-namespaces="no">
      <xsl:for-each-group select="*" group-starting-with="*[@tr-splitting-priority eq 'unconditional']">
        <tr-unconditional-split>
          <xsl:copy-of select="@*[starts-with(name(), 'tr')] except @tr-splitting-priority"/>
          <xsl:copy-of select="@id"/>
          <xsl:for-each-group select="current-group()" group-starting-with="*[@tr-splitting-priority eq 'conditional']">
            <xsl:choose>
              <xsl:when test="@tr-splitting-priority eq 'conditional'">
                <tr-conditional-split>
                  <xsl:attribute name="text-length" select="string-length(normalize-space(string-join(current-group(), '')))"/>
                  <xsl:copy-of select="@*[starts-with(name(), 'tr')] except @tr-splitting-priority"/>
                  <xsl:copy-of select="@id"/>
                  <xsl:sequence select="current-group()"/>
                </tr-conditional-split>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="text-length" select="string-length(normalize-space(string-join(current-group(), '')))"/>
                <xsl:sequence select="current-group()"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:for-each-group>
        </tr-unconditional-split>
      </xsl:for-each-group>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="html:tr-unconditional-split" mode="respect-hierarchy-among-conditional-split-candidates">
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@*"/>
      <xsl:variable name="processed" as="element(*)*"
        select="tr:group-according-to-heading(
                  html:tr-conditional-split, 
                  0,
                  @text-length
                )"
      />
      <xsl:attribute name="text-length" select="sum((@text-length, $processed/self::html:content/@text-length))"/>
      <content text-length="{@text-length}">
        <xsl:sequence select="tr:subsplit(* except html:tr-conditional-split, 
                                          (@text-length, 0)[1], 
                                          (ancestor-or-self::*/@tr-max-text-length, $heading-conf/@max-text-length)[1])"/>
      </content>
      <xsl:sequence select="$processed"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:function name="tr:is-conditional-split-level" as="xs:boolean">
    <xsl:param name="level" as="xs:integer?"/>
    <xsl:sequence select="$level &gt; 100"/>
  </xsl:function>

  <xsl:function name="tr:group-according-to-heading" as="element()*">
    <xsl:param name="nodes" as="element()*"/>
    <xsl:param name="level-to-dissolve"/><!-- remaining conditional split points at which no split occurred -->
    <xsl:param name="start-length" as="xs:integer?"/><!-- the length of a first text section before the first conditional split -->
    <xsl:variable name="level" as="xs:integer?" 
      select="for $min in min(for $dv in distinct-values($nodes/self::html:tr-conditional-split/@tr-heading-level[. castable as xs:integer][. &gt; $level-to-dissolve])
                              return xs:double($dv))
              return xs:integer($min)"/>
    <xsl:choose>
      <xsl:when test="not($level)">
        <xsl:sequence select="tr:subsplit($nodes, 
                                          sum(for $n in $nodes return string-length($n)), 
                                          (($nodes/ancestor-or-self::*[@tr-max-text-length])[last()]/@tr-max-text-length, $heading-conf/@max-text-length)[1])"/>
      </xsl:when>
      
      <!-- This seems rather complicated. It might help to look at a resulting debug file, 
        05.respect-hierarchy-among-conditional-split-candidates.xhtml
        There you’ll see some debugging info attached to the remaining <tr-conditional-split> elements.
        A thing that might facilitate calculations might be attaching each element’s position (the string
        length before, plus 1) as an attribute in a previous mode, in addition to the length. -->
      <!-- Remove true() here in order to enable the previous splitting of too long chapters at each section
        (probably need to introduce an option for that) -->
      <xsl:when test="true() or tr:is-conditional-split-level($level)">
        <xsl:variable name="same-level-nodes" as="element(*)*"
          select="$nodes/self::html:tr-conditional-split[@tr-heading-level = $level]"/>
        <xsl:variable name="same-level-total-text-lengths" as="xs:integer*">
          <xsl:for-each-group select="$nodes" group-starting-with="html:tr-conditional-split[@tr-heading-level = $level]">
            <xsl:sequence select="xs:integer(sum(current-group()/@text-length))"/>
          </xsl:for-each-group>
        </xsl:variable>
        <xsl:variable name="max-text-length" as="xs:integer" 
          select="(
                    ($nodes/ancestor-or-self::*[@tr-max-text-length]/@tr-max-text-length)[last()], 
                    $heading-conf/@max-text-length
                  )[1]"/>
        
        <xsl:variable name="same-level-text-offsets"
          select="tr:text-offsets($start-length, 
                                     $same-level-total-text-lengths)"/>
        <xsl:variable name="modulos" as="xs:double*"
          select="for $o in $same-level-text-offsets
                  return $o mod $max-text-length"/>
        <xsl:variable name="flags" select="(for $i in (1 to count($modulos) - 1)
                                            return ($modulos[$i + 1] lt $modulos[$i]
                                                    or 
                                                    $same-level-text-offsets[$i + 1] &gt; $same-level-text-offsets[$i] + $max-text-length) 
                                           )"/>
        <xsl:variable name="indexes" select="index-of($flags, true())"/>
        <xsl:variable name="split-nodes" as="element(*)*" select="$same-level-nodes[position() = $indexes]"/>
        <xsl:for-each-group select="$nodes" group-starting-with="*[some $s in $split-nodes
                                                                   satisfies (. is $s)]">
          <xsl:variable name="subitems" select="current-group()[position() gt 1]"/>
          <xsl:variable name="current-index" select="tr:index-of($same-level-nodes, .)" as="xs:integer?"/>
          <xsl:variable name="current-index-offset-at-start" as="xs:integer?"
            select="if ($current-index &gt; 1) then $same-level-text-offsets[$current-index - 1]
                    else if ($current-index = 1) then $start-length
                    else 0"/>
          <xsl:choose>
            <xsl:when test="some $s in $split-nodes satisfies (. is $s)">
              <tr-conditional-split tr-text-offsets="{$same-level-text-offsets}" tr-indexes="{$indexes}" 
                tr-flags="{$flags}" tr-modulos="{$modulos}">
                <xsl:copy-of select="@*"/>
                <xsl:variable name="current-pos-in-index-list" as="xs:integer" select="index-of($indexes, $current-index)"/>
                <xsl:variable name="next-index" select="$indexes[$current-pos-in-index-list + 1]" as="xs:integer?"/>
                <xsl:variable name="chunk-length" as="xs:integer"
                  select="if ($next-index) 
                          then $same-level-text-offsets[$next-index - 1] - $current-index-offset-at-start
                          else $same-level-text-offsets[last()] - $current-index-offset-at-start"/>
                <xsl:attribute name="text-length" select="$chunk-length"/>
                <xsl:attribute name="tr-current-index" select="$current-index, $next-index" separator=" "/>
                <content text-length="{@text-length}"  tr-heading-level="{$level}" tr-origin="B">
                  <xsl:sequence select="tr:subsplit(*, @text-length, $max-text-length)"/>
                </content>
                <xsl:for-each-group select="$subitems" 
                  group-starting-with="html:tr-conditional-split[@tr-heading-level cast as xs:integer eq $level]">
                  <content>
                    <xsl:sequence select="tr:subsplit(*, @text-length, $max-text-length)"/>
                  </content>
                  <xsl:sequence
                  select="tr:group-according-to-heading(
                            current-group()[position() gt 1], 
                            $level,
                            @text-length
                          )" />
                </xsl:for-each-group>
              </tr-conditional-split>
            </xsl:when>
            <xsl:otherwise>
              <xsl:for-each-group select="current-group()" 
                  group-starting-with="html:tr-conditional-split[@tr-heading-level = $level]">
                <xsl:choose>
                  <xsl:when test="self::html:tr-conditional-split[@tr-heading-level = $level]">
                    <content text-length="{@text-length}" tr-heading-level="{$level}" tr-origin="C">
                      <xsl:sequence select="tr:subsplit(*, @text-length, $max-text-length)"/>
                    </content>
                    <xsl:sequence
                      select="tr:group-according-to-heading(
                                current-group()[position() gt 1], 
                                $level,
                                @text-length
                              )" />
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:sequence
                      select="tr:group-according-to-heading(
                                current-group(), 
                                $level,
                                0
                              )" />
                  </xsl:otherwise>
                </xsl:choose>  
              </xsl:for-each-group>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:for-each-group>
      </xsl:when>
      <xsl:otherwise>
        <!-- It’s be preferable if we could keep together as many heading groups as fit into max-text-length.
          Therefore, all conditional-split levels (including the headings) are treated by the previous xsl:when.
          If it turns out to be buggy, you can treat the headings with the following, classic code, by
          removing "true() or" above. -->
        <xsl:for-each-group select="$nodes" group-starting-with="html:tr-conditional-split[@tr-heading-level cast as xs:integer eq $level]">
          <xsl:variable name="subitems" select="current-group()[position() gt 1]"/>
          <xsl:variable name="max-text-length" as="xs:integer" 
            select="(
                      ($nodes/ancestor-or-self::*[@tr-max-text-length]/@tr-max-text-length)[last()], 
                      $heading-conf/@max-text-length
                    )[1]"/>
          <tr-conditional-split>
            <xsl:copy-of select="@*"/>
            <content text-length="{@text-length}">
              <xsl:sequence select="tr:subsplit(*, @text-length, $max-text-length)"/>
            </content>
            <xsl:sequence
              select="tr:group-according-to-heading(
                        $subitems,
                        $level,
                        @text-length
                      )"
            />
          </tr-conditional-split>
        </xsl:for-each-group>
      </xsl:otherwise>
<!--      </xsl:otherwise>
        <xsl:sequence select="$nodes"/>
      </xsl:otherwise>
-->    </xsl:choose>
  </xsl:function>
  
  <xsl:function name="tr:text-offsets" as="xs:integer*">
    <xsl:param name="start" as="xs:integer*"/>
    <xsl:param name="deltas" as="xs:integer*"/>
    <xsl:variable name="_start" as="xs:integer+" select="if (not(empty($start))) then $start else 0"/>
    <xsl:sequence select="if (count($deltas) gt 0)
                          then tr:text-offsets(($start, $start[last()] + $deltas[1]), $deltas[position() gt 1])
                          else $start"/>
  </xsl:function>

  <xsl:function name="tr:subsplit" as="node()*">
    <xsl:param name="nodes" as="node()*"/>
    <xsl:param name="length" as="xs:double"/>
    <xsl:param name="max-length" as="xs:double"/>
    <xsl:choose>
      <xsl:when test="$length le number($max-length)">
        <xsl:sequence select="$nodes"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:for-each-group select="$nodes"
          group-starting-with="*[position() mod ((last() idiv (($length idiv number($max-length)) + 1)) + 1) eq 0]">
          <xsl:if test="position() gt 1">
            <tr-subsplit text-length="{string-length(normalize-space(string-join(current-group(), '')))}"
              tr-generated-id="{@tr-generated-id}"/>
          </xsl:if>
        </xsl:for-each-group>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>


  <!-- MODE: PARTIALLY-UNGROUP-TO-FINAL-SPLIT-POINTS
       Conditional splitting points will be removed if chunking is already small enough without them.
       Content that has been preserved in order to carry out subsplit size calculations will now be removed.
       One of two possible reasons will be given if a splitting point is put out of service:
       * the parent heading's group is short enough anyway, or
       * there is only minimal introductory content before the conditional split. 
       -->
  <xsl:template match="*[number(@text-length) 
                         le 
                         number((ancestor::*[@tr-max-text-length][1]/@tr-max-text-length, 
                                 $heading-conf/@max-text-length)[1])]/html:content"
    mode="partially-ungroup-to-final-split-points"/>


  <xsl:template match="*[number(@text-length) 
                         gt 
                         number((ancestor::*[@tr-max-text-length][1]/@tr-max-text-length, 
                                 $heading-conf/@max-text-length)[1])]/html:content"
    mode="partially-ungroup-to-final-split-points">
    <xsl:sequence select=".//html:tr-subsplit"/>
  </xsl:template>

  <xsl:template
    match="html:tr-conditional-split[
             sum(
               for $l in (
                 ../@text-length,
                 ..//html:tr-conditional-split/@text-length
               ) return number($l)
             ) le number((../@tr-max-text-length, $heading-conf/@max-text-length)[1])
           ]/@tr-generated-id"
    mode="partially-ungroup-to-final-split-points" priority="4">
    <xsl:attribute name="tr-dont-split-at-genid" select="."/>
    <xsl:attribute name="tr-reason" select="'parent-short-enough'"/>
  </xsl:template>

    <!-- close enough to previous headings: -->
  <xsl:template
    match="html:tr-conditional-split[
             sum(
               for $l in (
                 preceding-sibling::html:tr-conditional-split//@text-length, 
                 ../@text-length
               ) return number($l)
             ) le number((../@tr-max-text-length, $heading-conf/@max-text-length)[1]) * 0.03 ]"
    mode="partially-ungroup-to-final-split-points">
    <!-- only the subsplits (if present), but don't split here because it's too close to the parent heading -->
    <xsl:copy copy-namespaces="no">
      <xsl:copy-of select="@* except @tr-generated-id"/>
      <xsl:attribute name="tr-dont-split-at-genid" select="@tr-generated-id"/>
      <xsl:attribute name="tr-reason" select="'parent-introduction-short-enough'"/>
      <xsl:apply-templates select="html:content/html:tr-subsplit union html:tr-conditional-split" mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <!-- OUTPUT FILE NAMES -->
  
  <xsl:function name="tr:epub-type" as="xs:string">
    <xsl:param name="att" as="attribute(tr-epub-type)"/>
    <xsl:variable name="tokenized-types" select="tokenize($att, '\s+')" as="xs:string+"/>
    <xsl:variable name="first-available-type-in-conf" as="element(type)?" select="($epub-config/types/type[@name = $tokenized-types])[1]"/>
    <xsl:sequence select="string(($first-available-type-in-conf/@name, $att)[1])"/>
  </xsl:function>
  
  <xsl:template match="@tr-generated-id[../@tr-epub-type]" mode="output-file-names">
    <xsl:copy/>
    <xsl:variable name="same-type" 
      select="ancestor::*[last()]//@tr-epub-type[
                tr:epub-type(.) = tr:epub-type(current()/../@tr-epub-type) and 
                not(../@tr-dont-split-at-genid = current()/../@tr-generated-id)
              ]" as="attribute(tr-epub-type)+"/>
    <xsl:variable name="type-index" as="xs:integer" select="tr:index-of($same-type, ../@tr-epub-type)"/>
    <xsl:variable name="looked-up-name-component" select="$epub-config/types/type[@name = tr:epub-type(current()/../@tr-epub-type)]/(@file, @name)[1]" as="xs:string?"/>
    <xsl:variable name="normalized" select="if ($looked-up-name-component) 
                                            then $looked-up-name-component 
                                            else replace(replace(../@tr-epub-type, '^.+:', ''), '[^-_a-z0-9]', '_')" as="xs:string"/>
    <xsl:variable name="normalized" select="concat($html-prefix, $normalized)" as="xs:string"/>
    <xsl:attribute name="tr-output-name" 
      select="replace(
                $orig-filename, 
                '.+(\..+)$',
                concat(
                  if (count($same-type) gt 1) 
                  then concat($normalized, '-', tr:custom-pad(string($type-index), 3))
                  else $normalized,
                  '.xhtml'
                )
              )"/>
  </xsl:template>

  <xsl:template match="@tr-generated-id[not(../@tr-epub-type)]" mode="output-file-names">
    <xsl:copy/>
    <xsl:attribute name="tr-output-name" 
      select="replace(
                concat($html-prefix, $orig-filename), 
                '(\..+)$', 
                concat(
                  '_', 
                  tr:custom-pad(., 6),
                  if (../@tr-linear = 'no') then '_nolin' else '',
                  '.xhtml'
                )
              )"/>
  </xsl:template>


  <!-- Page list: -->

  <xsl:variable name="pgl" as="element(html:pgl)?">
    <xsl:variable name="pagenum-elts" as="element(*)*" select="tr:pagenums($chunks/html:chunks)"/>
    <xsl:if test="exists($pagenum-elts)">
      <pgl>
        <xsl:for-each select="$chunks/html:chunks/html:chunk">
          <xsl:variable name="filename" select="replace(@file, '^.+/', '')" as="xs:string"/>
          <xsl:variable name="chunk-pagenum-elts" as="element(*)*" select="tr:pagenums(.)"/>
          <xsl:for-each select="$chunk-pagenum-elts">
            <page name="{(self::*[@epub:type = 'pagebreak']/@title, 
                          self::*[@epub:type = 'pagebreak'][normalize-space()], 
                          replace(@id, '^page_?', '')
                         )[1]}" href="{$filename}{concat('#', @id)}"
              playOrder="{replace(generate-id(($root//*[@id eq current()/@id])[1]), '^.+?(\d+)$', '$1')}">
              <xsl:if test="position() eq 1">
                <xsl:attribute name="page-map-href" select="$filename"/>
              </xsl:if>
            </page>
          </xsl:for-each>
          <!-- fix for Sony reader bug (not able to flip back a page if a split file is not mentioned in page-map.xml) -->
          <xsl:if test="not($pagenum-elts/@epub:type = 'pagebreak')
                        and 
                        not(.//html:a[starts-with(@id, 'page_')]) 
                        and 
                        preceding-sibling::html:chunk//html:a[starts-with(@id, 'page_')]">
            <page name="" page-map-href="{$filename}"/>
          </xsl:if>
        </xsl:for-each>
      </pgl>
    </xsl:if>
  </xsl:variable>

  <xsl:function name="tr:pagenums" as="element(*)*">
    <xsl:param name="elts" as="element(*)"/><!-- a, span, … -->
    <xsl:variable name="a_page_" select="$elts//html:a[starts-with(@id, 'page_')]" as="element(html:a)*"/>
    <xsl:variable name="epub-typed" select="$elts//*[@epub:type = 'pagebreak']
                                                    [exists(@title) or normalize-space()]" as="element(*)*"/>
    <xsl:choose>
      <xsl:when test="exists($epub-typed)">
        <xsl:sequence select="$epub-typed"/>
      </xsl:when>
      <xsl:when test="exists($a_page_)">
        <xsl:sequence select="$a_page_"/>
      </xsl:when>
    </xsl:choose>
  </xsl:function>

  <xsl:function name="tr:sort" as="item()*">
    <xsl:param name="sequence" as="item()*"/>
    <xsl:for-each select="$sequence">
      <xsl:sort select="."/>
      <xsl:copy-of select="."/>
    </xsl:for-each>
  </xsl:function>

  <xsl:variable name="playOrder-generated-ids" as="xs:string*"
    select="for $i in tr:sort(
              distinct-values(
                for $n in ($raw-ncx//@playOrder union $pgl//@playOrder)
                return xs:integer($n)
              )
            ) 
            return xs:string($i)"/>

  <xsl:template match="html:pgl" mode="pageList">
    <pageList xmlns="http://www.daisy.org/z3986/2005/ncx/">
      <xsl:apply-templates mode="#current"/>
    </pageList>
  </xsl:template>

  <xsl:template match="html:pgl/html:page[not(@href)]" mode="pageList"/>

  <xsl:template match="html:pgl/html:page[@href]" mode="pageList">
    <pageTarget id="page_{@name}" type="normal" value="{@name}" xmlns="http://www.daisy.org/z3986/2005/ncx/"
      playOrder="{index-of($playOrder-generated-ids, @playOrder)}">
      <navLabel xmlns="http://www.daisy.org/z3986/2005/ncx/">
        <text xmlns="http://www.daisy.org/z3986/2005/ncx/">
          <xsl:value-of select="@name"/>
        </text>
      </navLabel>
      <content src="{concat($html-prefix, @href)}" xmlns="http://www.daisy.org/z3986/2005/ncx/"/>
    </pageTarget>
  </xsl:template>

  <xsl:template match="html:pgl" mode="page-map">
    <xsl:message>Writing page-map.xml</xsl:message>
    <xsl:result-document href="{$datadir}/chunks/page-map.xml" format="xml">
      <page-map xmlns="http://www.idpf.org/2">
        <xsl:apply-templates mode="#current"/>
      </page-map>
    </xsl:result-document>
  </xsl:template>

  <xsl:template match="html:pgl/html:page" mode="page-map">
    <page xmlns="http://www.idpf.org/2">
      <xsl:apply-templates select="@*" mode="#current"/>
    </page>
  </xsl:template>

  <xsl:template match="@page-map-href" mode="page-map">
    <xsl:attribute name="href" select="."/>
  </xsl:template>

  <xsl:template match="@href[../@page-map-href]" mode="page-map"/>

  <xsl:template match="@playOrder" mode="page-map"/>

  <!-- MODE: fullflatten -->
  
  <!-- a div or similar that could not be dissolved. It is not a heading by itself, but probably a 
    location for an unconditional split. Since the input for generation must be flat (so that it can
    be hierarchized…), we must dissolve every container that contains headings. -->
  <xsl:template match="*[@tr-splitting-priority]
                        [not(@tr-heading-level)]
                        [exists(
                          descendant::*/@tr-heading-level
                          union
                          descendant::*[tr:contains-token(@class, ('TOC_same', 'TOC_sub'))]
                        )]" mode="fullflatten">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
    </xsl:copy>
    <xsl:apply-templates mode="#current"/>
  </xsl:template>
  
  <xsl:template match="*[tr:contains-token(@class, 'TOC_same')]" mode="fullflatten">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:copy-of select="preceding::*[@tr-heading-level][1]/@tr-heading-level"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="*[tr:contains-token(@class, 'TOC_sub')]" mode="fullflatten">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:for-each select="preceding::*[@tr-heading-level][1]/@tr-heading-level">
        <xsl:attribute name="{name()}" select="number(.) + 1"/>
      </xsl:for-each>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <!-- NCX (ToC) EXPORT: -->

  <xsl:template match="html:html" mode="raw-ncx">
    <xsl:variable name="first-export-file"
      select="tr:export-filename(($output-file-names/html:html/html:body//@tr-generated-id)[1])"/>
    <navMap xmlns="http://www.daisy.org/z3986/2005/ncx/" tr-first-export-file="{$first-export-file}">
      <xsl:choose>
        <xsl:when test="html:body/*/@tr-heading-level[not(../@tr-exclude-from-nav)]
                                                     [not(tr:is-conditional-split-level(.))]">
          <xsl:sequence select="tr:group-for-ncx(
                                  html:body/*, 
                                  xs:integer(min(html:body/*/@tr-heading-level[not(../@tr-exclude-from-nav)]
                                                                              [not(tr:is-conditional-split-level(.))])), 
                                  true()
                                )"/>
        </xsl:when>
        <xsl:when test="html:body//@tr-heading-level[not(tr:is-conditional-split-level(.))]">
          <xsl:variable name="first-container-with-tr-heading-level-elements" as="element()"
            select="(.//*[*[@tr-heading-level[not(tr:is-conditional-split-level(.))]]])[1]"/>
          <xsl:sequence select="tr:group-for-ncx(
                                  $first-container-with-tr-heading-level-elements/*, 
                                  xs:integer(min($first-container-with-tr-heading-level-elements/*/@tr-heading-level[not(tr:is-conditional-split-level(.))])), 
                                  true()
                                )"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message
            select="'&#xa;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#xa;',
            'INFO: No heading elements found. All content will be written to one file.&#xa; Please consider your configuration file.',
            '&#xa;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#xa;'"/>
          <navPoint id="" class="default" playOrder="1" xmlns="http://www.daisy.org/z3986/2005/ncx/">
            <navLabel xmlns="http://www.daisy.org/z3986/2005/ncx/">
              <text xmlns="http://www.daisy.org/z3986/2005/ncx/">***</text>
            </navLabel>
            <content src="{$first-export-file}" xmlns="http://www.daisy.org/z3986/2005/ncx/"/>
          </navPoint>
        </xsl:otherwise>
      </xsl:choose>
    </navMap>
  </xsl:template>

  <xsl:template match="html:br" mode="br-to-space">
    <xsl:text> </xsl:text>
  </xsl:template>

  <xsl:template match="html:a" mode="br-to-space"/>

  <xsl:template match="html:span[@class='chapterauthor']" mode="br-to-space">
    <xsl:apply-templates select="node()" mode="#current"/>
    <xsl:text>– </xsl:text>
  </xsl:template>

  <!-- add @epub:type="pagebreak" to page anchors (normally, these a elements should be renamed to span)
       see http://www.idpf.org/accessibility/guidelines/content/xhtml/pagenum.php
  -->
  <xsl:template match="html:a[starts-with(@id, 'page_')]" mode="remove-surrounding-text">
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:if test="$final-pub-type eq 'EPUB3'">
        <xsl:attribute name="epub:type" select="'pagebreak'"/>
        <xsl:attribute name="title" select="replace(@id, '^page_?', '')"/>
      </xsl:if>
      <xsl:apply-templates select="node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <!-- preserve newlines in pre tags -->
  
  <xsl:template match="html:pre" mode="remove-surrounding-text">
    <xsl:copy-of select="."/>
  </xsl:template>

  <xsl:template name="ncx">
    <ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1" xml:lang="en-US">
      <!-- to-do: copy metadata information -->
      <head>
        <meta name="dtb:uid"
          content="{if ($metadata/dc:identifier[@opf:scheme eq 'ISBN'])
          then $metadata/dc:identifier[@opf:scheme eq 'ISBN'] 
          else tr:get-dc-identifier()}"
        />
      </head>
      <docTitle>
        <text>
          <xsl:value-of select="$metadata/dc:title"/>
        </text>
      </docTitle>
      <xsl:apply-templates select="$raw-ncx" mode="play-order"/>
      <xsl:apply-templates select="$pgl" mode="pageList"/>
    </ncx>
  </xsl:template>

  <!-- EPUB Navigation Document, EPUB 3.0, supersedes NCX -->
  <!-- body class to avoid displaying or styling via CSS -->
  <xsl:template name="toc-nav">
    <xsl:param name="toc-ncx" as="element(ncx:ncx)"/>
    <xsl:param name="landmarks" as="element(*)*"/>
    <html epub:prefix="tr: http://transpect.io">
      <head>
        <link href="styles/stylesheet.css" type="text/css" rel="stylesheet"/>
        <title>EPUB Navigation: Toc</title>
        <xsl:choose>
          <xsl:when test="$epub-config/types/type[@name = 'toc']/@hidden = 'true'">
            <!-- I thought about <meta name="spine" content="false"/> but then there’s the link
            from the landmarks nav to the toc nav and this necessitates that the whole nav doc 
            is in the spine. I’ll make it linear=no. 
            The issue that I’m trying to solve is that the generated nav doc appears first in 
            spine, right before the cover.
            It wasn’t skipped in Bluefire, therefore reverting to spine=false, removing the 
            link in the generated landmarks. -->
            <meta name="spine" content="false"/>
          </xsl:when>
          <xsl:otherwise>
            <!-- so that the generated cover will be sorted between cover 
              (sequence # 1) and the remainder of the exported files -->
            <meta name="sequence" content="($epub-config/types/@nav-spine-pos, 1.5)[1]"/>
          </xsl:otherwise>
        </xsl:choose>
        
      </head>
      <body class="nav-body">
        <xsl:call-template name="landmarks">
          <xsl:with-param name="landmarks" select="$landmarks"/>
        </xsl:call-template>
        <nav epub:type="toc" id="{$toc-nav-id}">
          <xsl:if test="not($epub-config/types/type[@name = 'toc']/@heading = '')">
            <h1>
              <xsl:value-of select="($epub-config/types/type[@name = 'toc']/@heading, 'Table of Contents')[1]"/>
            </h1>
          </xsl:if>
          <ol>
            <xsl:apply-templates select="$toc-ncx/ncx:navMap" mode="nav-xhtml"/>
          </ol>
        </nav>
        <xsl:if test="$pgl and not($final-pub-type = ('EPUB2'))">
          <xsl:call-template name="page-list-nav-inner"/>
        </xsl:if>
      </body>
    </html>
  </xsl:template>

  <xsl:variable name="toc-nav-id" select="'toc-navigation'" as="xs:string"/>

  <!-- only page-list-nav-inner seems to be used -->
  <xsl:template name="page-list-nav">
    <xsl:param name="toc-ncx" as="element(ncx:ncx)"/>
    <xsl:param name="landmarks" as="element(*)*"/>
    <html>
      <head>
        <link href="styles/stylesheet.css" type="text/css" rel="stylesheet"/>
        <title>EPUB Navigation: Page list</title>
      </head>
      <body class="nav-body">
        <xsl:call-template name="page-list-nav-inner"/>
      </body>
    </html>
  </xsl:template>
  
  <xsl:template name="page-list-nav-inner">
    <nav epub:type="page-list" id="page-list-navigation" hidden="hidden">
      <ol>
        <xsl:for-each select="$pgl/html:page[normalize-space(@name)]">
          <li>
            <a href="{@href}" srcpath="pgl_{generate-id()}">
              <xsl:value-of select="@name"/>
            </a>
          </li>
        </xsl:for-each>
      </ol>
    </nav>
  </xsl:template>

  <xsl:template name="landmarks">
    <xsl:param name="landmarks" as="element(*)*"/>
    <!-- If this exists ⇒ The toc is already in the content -->
    <xsl:variable name="content-toc-id" as="attribute()?"
      select="($landmarks[tr:contains-token(@epub:type, 'toc')]/(@id, @tr-generated-id))[1]"/>
    <nav epub:type="landmarks" id="landmarks-navigation">
      <xsl:if test="$epub-config/types/type[@name = 'landmarks']/@hidden = 'true'">
        <xsl:attribute name="hidden" select="'hidden'"/>
      </xsl:if>
      <xsl:if test="not($epub-config/types/type[@name = 'landmarks']/@heading = '')">
        <h1>
          <xsl:value-of select="($epub-config/types/type[@name = 'landmarks']/@heading, 'Guide')[1]"/>
        </h1>
      </xsl:if>
      <ol>
        <xsl:variable name="rendered-toc" as="element(*)?"
          select="key('by-id', $epub-config/types/type[@name = 'toc']/@fallback-id-for-landmark)"/>
        <xsl:choose>
          <xsl:when test="not($content-toc-id) and 
                          not($epub-config/types/type[@name = 'toc']/@hidden = 'true')">
          <!-- nav doc is not already in spine, but generated toc will be.
            Link to generated toc. 
            Otherwise, don’t link to generated because it is not allowed to link to non-spine items -->
          <li>
            <a epub:type="toc" href="#{$toc-nav-id}" srcpath="landmarks-link-to-toc">
              <xsl:value-of select="($epub-config/types/type[@name = 'toc']/@heading, 'Table of Contents')[1]"/>
            </a>
          </li>
          </xsl:when>
          <xsl:when test="$epub-config/types/type[@name = 'toc']/@hidden = 'true'
                          and
                          exists($rendered-toc)">
            <xsl:variable name="unresolved-href" as="attribute(href)">
              <xsl:attribute name="href" select="concat('#', $epub-config/types/type[@name = 'toc']/@fallback-id-for-landmark)"/>
            </xsl:variable>
            <li>
              <a epub:type="toc" srcpath="landmarks-link-to-toc">
                <xsl:apply-templates select="$unresolved-href" mode="resolve-refs">
                  <xsl:with-param name="element" select="$rendered-toc"/>
                </xsl:apply-templates>
                <xsl:value-of select="($epub-config/types/type[@name = 'toc']/@heading, 'Table of Contents')[1]"/>
              </a>
          </li>
          </xsl:when>
        </xsl:choose>
        <xsl:variable name="prelim" as="element(html:li)*">
          <xsl:apply-templates select="$landmarks" mode="nav-landmarks"/>
        </xsl:variable>
        <xsl:sequence select="$prelim"/>
        <!-- That would discard an index landmark in a backmatter chunk: --> 
        <!--<xsl:for-each-group select="$prelim" group-by="replace(html:a/@href, '#.+$', '')">
          <xsl:sequence select="."/>
        </xsl:for-each-group>-->
      </ol>
    </nav>
  </xsl:template>

  <xsl:template match="*" mode="nav-landmarks">
    <xsl:variable name="landmark-type" as="xs:string+" select="tokenize(@epub:type, '\s+')[. = $landmark-types]"/>
    <li>
      <a srcpath="landmarks-{generate-id()}">
        <xsl:attribute name="epub:type" select="string-join($landmark-type, ' ')"/>
        <xsl:variable name="unresolved-href" as="attribute(href)">
          <xsl:attribute name="href" select="concat('#', (@id, @tr-generated-id)[1])"/>
        </xsl:variable>
        <xsl:apply-templates select="$unresolved-href" mode="resolve-refs">
          <xsl:with-param name="element" select="."/>
        </xsl:apply-templates>
        <xsl:value-of select="($epub-config/types/type[@name = $landmark-type]/@heading, $landmark-type)[1]"/>
      </a>
    </li>
  </xsl:template>

  <!-- put spine linear info into meta -->
  <xsl:template match="html:head" mode="resolve-refs">
    <xsl:param name="pos" tunnel="yes"/>
    <xsl:copy>
      <xsl:apply-templates select="@*, node()" mode="#current"/>
      <xsl:if test="../../@tr-linear = 'no'">
        <meta name="linear" content="false"/>
      </xsl:if>
      <meta name="sequence" content="{$pos}"/>
    </xsl:copy>
  </xsl:template>

  <!-- for tocs that are already in the content (should match html:nav instead of *, but people are 
    sometimes using <h1 epub:type="toc"> and the like): -->
  <xsl:template match="*[@epub:type = 'toc']" mode="resolve-refs">
    <xsl:param name="landmarks" as="element(*)*" tunnel="yes"/>
    <xsl:call-template name="landmarks">
      <xsl:with-param name="landmarks" select="$landmarks"/>
    </xsl:call-template>
    <xsl:next-match/>
    <xsl:if test="$pgl and not($final-pub-type = ('EPUB2'))">
      <xsl:call-template name="page-list-nav-inner"/>
    </xsl:if>
  </xsl:template>
  
  <xsl:template match="@error-message" mode="resolve-refs"/>
  

  <xsl:template match="ncx:ncx | ncx:navMap | ncx:navLabel | ncx:text" mode="nav-xhtml">
    <xsl:apply-templates mode="#current"/>
  </xsl:template>

  <xsl:template match="ncx:navPoint" mode="nav-xhtml">
    <xsl:choose>
      <xsl:when test="ncx:navPoint and not( parent::navMap )">
        <li>
          <xsl:apply-templates select="@id | @class" mode="#current"/>
          <xsl:apply-templates select="ncx:content" mode="#current"/>
          <ol>
            <xsl:apply-templates select="ncx:navPoint" mode="#current"/>
          </ol>
        </li>
      </xsl:when>
      <xsl:otherwise>
        <li>
          <xsl:apply-templates select="@id | @class" mode="#current"/>
          <xsl:apply-templates select="ncx:content" mode="#current"/>
        </li>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="ncx:content" mode="nav-xhtml">
    <a href="{@src}" srcpath="nav-{generate-id()}">
      <xsl:apply-templates select="preceding-sibling::ncx:navLabel[1]" mode="#current"/>
    </a>
  </xsl:template>


  <xsl:function name="tr:group-for-ncx" as="element()*">
    <xsl:param name="nodes" as="element()*"/>
    <xsl:param name="level" as="xs:integer"/>
    <xsl:param name="topmost" as="xs:boolean"/>
    <xsl:for-each-group select="$nodes" 
      group-starting-with="*[@tr-heading-level[not(../@tr-exclude-from-nav)]][xs:integer(@tr-heading-level) = $level][not(@dissolved-for-semiflatten eq 'true')]">
      <xsl:choose>
        <xsl:when test="xs:integer(@tr-heading-level) = $level">
          <xsl:variable name="actual-heading"
            select="if (@tr-split-for) then key('by-genid', @tr-split-for, $root) else ." as="element()"/>
          <xsl:if test="not(tr:contains-token($actual-heading/@class, '_notoc'))">
            <navPoint id="" class="default" playOrder="{replace(@tr-generated-id, '^.+?(\d+)$', '$1')}"
              xmlns="http://www.daisy.org/z3986/2005/ncx/">
              <navLabel xmlns="http://www.daisy.org/z3986/2005/ncx/">
                <xsl:variable name="br-to-space" as="xs:string">
                  <xsl:choose>
                    <xsl:when test="$actual-heading/(@title | svg:title)">
                      <xsl:value-of select="$actual-heading/(@title | svg:title)"/>
                    </xsl:when>
                    <xsl:when test="tr:is-conditional-split-level($level)">
                      <xsl:choose>
                        <xsl:when test="matches($actual-heading, '^[\s\p{Po}\p{So}]+$')
                                        and matches($actual-heading, '[\p{Po}\p{So}]')">
                          <xsl:value-of 
                            select="string-join((
                                      normalize-space($actual-heading),
                                      tr:abbreviate-for-toc($actual-heading/following-sibling::*[matches(., '[\p{L}\p{N}]')][1])
                                    ), '&#xa;&#xa;')"/>
                        </xsl:when>
                        <xsl:when test="matches($actual-heading, '^[\s\p{Zs}]*$')">
                          <xsl:value-of 
                            select="tr:abbreviate-for-toc($actual-heading/following-sibling::*[matches(., '[\p{L}\p{N}]')][1])"/>
                        </xsl:when>
                        <xsl:otherwise>
                          <xsl:value-of 
                            select="tr:abbreviate-for-toc($actual-heading)"/>
                        </xsl:otherwise>
                      </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:apply-templates select="$actual-heading" mode="br-to-space"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:variable>
                <text xmlns="http://www.daisy.org/z3986/2005/ncx/">
                  <xsl:value-of
                    select="translate(replace(normalize-space($br-to-space), '&#x2009;', ' '), '&#x2011;&#x202f;', '- ')"/>
                </text>
              </navLabel>
              <xsl:variable name="genid" as="xs:string"
                select="if(@tr-source-element-without-id-attribute and @tr-split-delegation-to ne '')
                      then $fullflatten//*[@tr-generated-id[. eq current()/@tr-split-delegation-to]]/@id
                      else (@id, @tr-generated-id, .//@id)[1]"/>
              <content genid="{$genid}" xmlns="http://www.daisy.org/z3986/2005/ncx/"/>
              <xsl:variable name="next-level" as="xs:integer*"
                select="(current-group() except .)/@tr-heading-level[not(tr:is-conditional-split-level(.))]"/>
              <!--<xsl:message select="'nl1 ', $next-level"></xsl:message>-->
              <xsl:if test="min($next-level) = $level">
                <!-- GI 2017-02-25: I’ve seen this message raised when processing the interview in the backmatter of
                  unionsverlag/legacy/00399. It was a conditional split with level=102 (corresponds to p.emptyline
                  in the UV splitting conf). The result looks ok. Haven’t investigated whether the message is 
                  rightfully raised or whether it can be suppressed. -->
                <xsl:message>Something's wrong (msg a): same level <xsl:value-of select="$level"/> in <xsl:sequence
                    select="(current-group() except .)[position() = (1 to 3)]"/> … <xsl:sequence
                    select="(current-group() except .)[last()]"/>
                </xsl:message>
              </xsl:if>
              <xsl:if test="exists($next-level)">
                <!--<nl min="{min($next-level)}" levels="{$next-level}"/>-->
                <xsl:sequence select="tr:group-for-ncx(current-group()
                                                       except ., min($next-level), false())"/>
              </xsl:if>
              <!-- https://redmine.le-tex.de/issues/8015
              The following will only give the results in correct order if there is no mix between proper heading
              and TOC_sub headings. -->
              <xsl:apply-templates select="current-group()/descendant-or-self::*[@tr-heading-level[. = current()/@tr-heading-level + 1]]
                                                        [tr:contains-token(@class, 'TOC_sub')]"
                                   mode="raw-ncx"/>
            </navPoint>
            <xsl:apply-templates select="current-group()/descendant-or-self::*[@tr-heading-level[. = current()/@tr-heading-level]]
                                                      [tr:contains-token(@class, 'TOC_same')]"
                                 mode="raw-ncx"/>
          </xsl:if>
        </xsl:when>
        <xsl:when test="current-group()//@tr-heading-level[not(../@tr-split-delegation-to)][not(../@tr-exclude-from-nav)]">
          <!-- lower level (i.e., higher integer number – may occur in 1st group) -->
          <!--<xsl:message select="'nl2 level ', $level, ', ', min(current-group()//@tr-heading-level)"></xsl:message>-->
          <xsl:if test="min(current-group()//@tr-heading-level[not(../@tr-split-delegation-to)][not(../@tr-exclude-from-nav)]) = $level">
            <xsl:message>Something's wrong (msg b): same level <xsl:value-of select="$level"/> at current group first item
                <xsl:sequence select="."/> in <xsl:sequence select="(current-group() except .)[position() = (1 to 5)]"/>… 
              Possible issue: there are headings deeply nested in the markup above. 
              A solution might be do add the nesting tags in the list of dissolvable
              elements in tr:dissolvable-for-semiflatten(). </xsl:message>
          </xsl:if>
          <xsl:sequence
            select="tr:group-for-ncx(current-group(), xs:integer(min(current-group()//@tr-heading-level)), false())"/>
        </xsl:when>
        <xsl:when test="$topmost 
                        and 
                        (matches(string-join(current-group(), ''), '\S'))
                        and 
                        not( (: nav entry should be suppressed if @generated-frontmatter-title='' :)
                          exists($heading-conf/@generated-frontmatter-title) 
                          and 
                          not(normalize-space($heading-conf/@generated-frontmatter-title))
                        )">
          <!-- generic front matter nav point before first actual split point -->
          <navPoint id="" class="default" playOrder="0" xmlns="http://www.daisy.org/z3986/2005/ncx/">
            <navLabel>
              <text>
                <xsl:value-of
                  select="(
                                       $heading-conf/@generated-frontmatter-title,
                                       'Frontmatter'
                                      )[1]"
                />
              </text>
            </navLabel>
            <content genid="{(current-group()//@id)[1]}"/>
            <xsl:variable name="next-level" select="(current-group() except .)/@tr-heading-level[not(../@tr-exclude-from-nav)]" as="xs:integer*"/>
            <!--            <xsl:message select="'nl3 level ', $level, ', ', min($next-level)"></xsl:message>-->
            <xsl:if test="min($next-level) = $level">
              <xsl:message>Something's wrong (msg c): same level <xsl:value-of select="$level"/> in <xsl:sequence
                  select="current-group() except ."/></xsl:message>
            </xsl:if>
            <xsl:if test="exists($next-level)">
              <xsl:sequence select="tr:group-for-ncx(current-group() except ., min($next-level), false())"/>
            </xsl:if>
          </navPoint>
        </xsl:when>
      </xsl:choose>
    </xsl:for-each-group>
  </xsl:function>

  <xsl:template match="*[tr:contains-token(@class, ('TOC_same', 'TOC_sub'))]" mode="raw-ncx">
    <navPoint id="" class="default" playOrder="{replace(@tr-generated-id, '^.+?(\d+)$', '$1')}" 
      xmlns="http://www.daisy.org/z3986/2005/ncx/">
      <navLabel>
        <text>
          <xsl:value-of select="(@title, normalize-space(.))[1]"/>
        </text>
      </navLabel>
      <content genid="{(@id, @tr-generated-id)[1]}"/>
    </navPoint>
  </xsl:template>


  <xsl:template match="ncx:navPoint/ncx:content/@genid" mode="play-order">
    <xsl:param name="final-chunks" as="document-node(element(html:chunks))" tunnel="yes"/>
    <xsl:variable name="chunk" select="key('chunk-by-id', ., $final-chunks)" as="element(html:chunk)*"/>
    <xsl:variable name="elt" select="key('by-any-id-available', ., $final-chunks)" as="element(*)*"/>
    <xsl:variable name="id" select="($elt/descendant-or-self::*/@id)[1]" as="attribute(id)?"/>
    <xsl:if test="count($chunk) gt 1">
      <xsl:message>[ERROR] Error in source data: More than one element with id <xsl:value-of select="."/>.
        Only considering the first one.</xsl:message>
    </xsl:if>
    <xsl:choose>
      <xsl:when
        test="count($chunk) eq 0 
                      and (. = '')
                      and count(//ncx:content[@genid = '']) = 1">
        <!-- probably frontmatter chunk -->
        <xsl:variable name="chunks-with-id"
          select="for $g in //ncx:content[not(@genid = '')]/@genid
                                                    return key('chunk-by-id', $g, $final-chunks)"
          as="element(html:chunk)*"/>
        <xsl:variable name="left-chunk" as="element(html:chunk)*"
          select="$final-chunks/*/*[not(some $c in $chunks-with-id satisfies ($c is current()))]"/>
        <xsl:if test="count($left-chunk) eq 1">
          <xsl:attribute name="src" select="replace($left-chunk[1]/@file, '^.+/', $html-prefix)"/>
        </xsl:if>
      </xsl:when>
      <xsl:when test="count($chunk) eq 0 and count($elt) ge 1 and count($id) = 0">
        <xsl:message>[ERROR] Error in intermediate data: Element with generated id <xsl:value-of select="."/> does not have a proper ID.</xsl:message>
      </xsl:when>
      <xsl:when test="count($chunk) eq 0 and count($elt) ge 1">
        <xsl:attribute name="src" select="concat(
                                            replace($elt[1]/ancestor::html:chunk/@file, '^.+/', $html-prefix),
                                            '#',
                                            $id
                                          )"/>
      </xsl:when>
      <xsl:when test="count($chunk) eq 0">
        <xsl:message>[ERROR] Error in source data: There is no element with id <xsl:value-of select="."/>.</xsl:message>
        <xsl:message select="../.."></xsl:message>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="pos" select="index-of($chunk[1]//@id, .)" as="xs:integer+"/>
        <xsl:attribute name="src" select="concat(
                                            replace($chunk[1]/@file, '^.+/', $html-prefix), concat('#', current())
                                          )"
        />
      </xsl:otherwise>
    </xsl:choose>

  </xsl:template>

  <xsl:template match="ncx:navMap/@tr-first-export-file" mode="play-order"/>

  <xsl:template match="ncx:navPoint/@playOrder" mode="play-order">
    <xsl:attribute name="{name()}" select="index-of($playOrder-generated-ids, .)"/>
  </xsl:template>


  <xsl:template match="ncx:navPoint/@id " mode="play-order">
    <xsl:attribute name="{name()}" select="string-join(('i', string(tr:index-of(//ncx:navPoint, ..))), '')"/>
  </xsl:template>

  <xsl:template match="ncx:navPoint/@class" mode="play-order">
    <xsl:attribute name="class" select="string-join(('h', string(count(ancestor::ncx:navPoint))), '')"/>
  </xsl:template>



  <xsl:function name="tr:chunks" as="element(html:chunks)">
    <xsl:param name="split-genids" as="xs:string+"/>
    <chunks common-dir-elimination-regex="{$common-dir-elimination-regex}">
      <xsl:for-each select="(1 to count($split-genids))">
        <xsl:variable name="left-id" select="$split-genids[current()]" as="xs:string"/>
        <xsl:variable name="left" select="key('by-genid', $left-id, $root)"/>
        <xsl:variable name="right-id" select="$split-genids[current() + 1]" as="xs:string?"/>
        <xsl:variable name="right" select="key('by-genid', $right-id, $root)"/>
        <xsl:variable name="local-nodes"
          select="$left union (
                                                   if (exists($right)) 
                                                   then $left/following::* intersect $right/preceding::*
                                                     else $left/following::* 
                                                 )"
          as="node()*"/>
        <xsl:variable name="prelim-export" as="element(html:html)">
          <xsl:apply-templates select="$root" mode="export-chunk-with-surroundings">
            <xsl:with-param name="split-genids" select="$split-genids" tunnel="yes"/>
            <xsl:with-param name="split-genid" select="$left-id" tunnel="yes"/>
            <xsl:with-param name="node-genids" select="for $n in $local-nodes return generate-id($n)" tunnel="yes"/>
            <xsl:with-param name="ancestor-genids" select="for $n in $local-nodes/ancestor::* return generate-id($n)"
              tunnel="yes"/>
          </xsl:apply-templates>
        </xsl:variable>
        <xsl:variable name="remove-surrounding-text" as="element(html:html)">
          <xsl:apply-templates select="$prelim-export" mode="remove-surrounding-text"/>
        </xsl:variable>
        <xsl:variable name="body-elts" select="$remove-surrounding-text/html:body/*" as="element(*)*"/>
        <xsl:message>Chunk <xsl:value-of select="tr:export-filename($left-id)"/> (<xsl:value-of select="position()"/> of <xsl:value-of 
          select="last()"/>): <xsl:value-of select="count($body-elts)"/> element<xsl:value-of
          select="if(count($body-elts) gt 1) then 's, starting with ' else ': '"/><xsl:value-of
          select="local-name($body-elts[1])"/></xsl:message>
        <chunk file="{$datadir}/chunks/{tr:export-filename($left-id)}" startnum="{replace($left-id, '^.+?(\d+)$', '$1')}">
          <xsl:copy-of select="key('by-tr-genid', $left-id, $output-file-names)/@tr-linear"/>
          <xsl:sequence select="$remove-surrounding-text"/>
        </chunk>
      </xsl:for-each>
    </chunks>
  </xsl:function>
  
  <xsl:template match="html:body/text()[not(normalize-space())]" priority="2" mode="remove-surrounding-text remove-other-pub-type-content"/>

  <!-- Save this invalid epub-type until the following template will dissolve it -->
  <xsl:template match="html:span/@epub:type[. eq 'dc:identifier']" mode="#all" priority="3">
    <xsl:copy/>
  </xsl:template>

  <xsl:function name="tr:get-dc-identifier" as="element(dc:identifier)?">
    <xsl:sequence select="$epub-config
                            /metadata
                              /(
                                dc:identifier[@format = $final-pub-type], 
                                dc:identifier[not(@format)]
                              )[1]"/>
  </xsl:function>

  <xsl:template match="html:span[(@epub:type, @tr-epub-type)[1] = 'dc:identifier']" mode="remove-surrounding-text remove-other-pub-type-content">
    <xsl:variable name="conf-item" as="element(dc:identifier)?" 
      select="tr:get-dc-identifier()"/>
    <xsl:choose>
      <xsl:when test="$conf-item">
        <xsl:value-of select="$conf-item"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="."/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:param name="newline-regex" select="'(&#x85;|&#x2028;|&#x2029;|&#xd;&#xa;|&#x10fb;|\n)'" as="xs:string"/>

  <!-- remove line breaks in input -->
  <xsl:template match="html:body//html:*[not(local-name() = ('pre', 'script'))]/text()[matches(., $newline-regex)]" mode="remove-surrounding-text remove-other-pub-type-content">
    <xsl:value-of select="replace(., concat('\s*', $newline-regex, '\s*'), '&#x20;')"/>
  </xsl:template>

  <xsl:template match="html:body//html:*[matches(local-name(), '^(h\d|p|div|section|aside|nav|figure|img|footer|blockquote|header|ol|ul|li|dd|dt|dl|td|th|table|tfoot|hr)$')][$indent = 'selective']" 
    mode="remove-surrounding-text remove-other-pub-type-content add-selective-indent" priority="2">
    <xsl:text>&#xa;</xsl:text>
    <xsl:sequence select="string-join(for $i in 0 to count(ancestor::*) return '  ', '')"/>
    <xsl:next-match/>
  </xsl:template>

  <xsl:template match="html:body//html:*[matches(local-name(), '^(body|div|section|aside|nav|figure|footer|blockquote|header|ol|ul|dl|table|tfoot)$')][$indent = 'selective']"
    mode="remove-surrounding-text remove-other-pub-type-content add-selective-indent">
    <xsl:copy>
      <xsl:apply-templates select="@*, node()" mode="#current"/>
      <xsl:text>&#xa;</xsl:text>
      <xsl:sequence select="string-join(for $i in 0 to count(ancestor::*) return '  ', '')"/>
    </xsl:copy>
  </xsl:template> 


  <!-- remove process attributes starting with tr: -->
  <xsl:template match="@*[starts-with(local-name(), 'tr-')]" mode="resolve-refs"/>

  <!-- remove items that should be removed according to heading-conf: -->
  <xsl:template match="*[generate-id() = $removable-ids]" mode="export-chunk-with-surroundings export-chunk-subtree mobi-htm"/>

  <!-- remove mobipocket-specific content: -->
  <xsl:template match="html:span[@class='mobi']"
    mode="export-chunk-with-surroundings export-chunk-subtree remove-other-pub-type-content">
    <xsl:if test="$final-pub-type eq 'mobi'">
      <xsl:apply-templates mode="#current"/>
    </xsl:if>
  </xsl:template>
  <xsl:template match="html:span[@class=('EPUB','epub')]"
    mode="export-chunk-with-surroundings export-chunk-subtree remove-other-pub-type-content">
    <xsl:if test="$final-pub-type = ('epub', '')">
      <xsl:apply-templates mode="#current"/>
    </xsl:if>
  </xsl:template>

  <!-- Important "upward projection" or slicing template. 
       Using generated ids instead of intersecting the nodes (better performance). -->
  <xsl:template match="*" mode="export-chunk-with-surroundings" priority="2">
    <xsl:param name="split-genids" tunnel="yes" as="xs:string+"/>
    <xsl:param name="split-genid" tunnel="yes" as="xs:string"/>
    <xsl:param name="node-genids" tunnel="yes" as="xs:string+"/>
    <xsl:param name="ancestor-genids" tunnel="yes" as="xs:string+"/>
    <xsl:choose>
      <xsl:when test="generate-id() = $ancestor-genids">
        <xsl:next-match/>
        <!-- identity template in the same mode -->
      </xsl:when>
      <xsl:when test="generate-id() = $node-genids">
        <xsl:apply-templates select="." mode="export-chunk-subtree"/>
      </xsl:when>
      <!-- all other nodes (nor the projection nodes and their subtrees, nor their common ancestors) will be discarded -->
    </xsl:choose>
  </xsl:template>
  
    <!-- make sure that every element referenced in the toc has an id: -->
  <xsl:template match="*[not(@id)]
                        [
                          exists(
                            key('by-tr-genid', generate-id(), $semiflatten)
                              [@tr-heading-level]
                          )
                        ]" 
                mode="export-chunk-with-surroundings export-chunk-subtree">
    <xsl:copy copy-namespaces="no">
      <xsl:attribute name="id" select="generate-id()"/>
      <xsl:apply-templates select="@*, node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <!-- This special ancestor is allowed to carry his brother html:head with him: -->
  <xsl:template match="html:body" mode="export-chunk-with-surroundings" priority="-0.6">
    <xsl:apply-templates select="preceding::html:head"/>
    <xsl:text>&#xa;    </xsl:text>
    <xsl:next-match/>
  </xsl:template>

  <!-- priority has to be lower than default priority for match="*" (which is -0.5), 
       but higher than the catch-all priority specified above -->
  <xsl:template
    match="*[not(@id)][generate-id() = ($partially-ungroup-to-final-split-points/html:body//@tr-generated-id, $partially-ungroup-to-final-split-points/html:body//@tr-dont-split-at-genid)]"
    priority="-0.6" mode="export-chunk-with-surroundings export-chunk-subtree mobi-htm">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="id" select="(@id, generate-id())[1]"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template
    match="*[not(@id)][@epub:type]"
    priority="-0.65" mode="export-chunk-with-surroundings export-chunk-subtree mobi-htm">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="id" select="generate-id()"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <!-- audio spans will not be dealt with by above templates, but only by the following,
       id-adding template. This implies that no audio span may serve as a splitting candidate. -->
  <xsl:template match="*[@class eq 'au'][not(starts-with(@id, 'au-'))]"
    mode="export-chunk-with-surroundings export-chunk-subtree mobi-htm">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="id" select="generate-id()"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>



  <!-- MODE: resolve-refs
       Will be applied during final export. The links haven't been adjusted in the chunks yet because
       it's easier to look up the target file name after the chunk that the target is in. -->
  <xsl:template match="@href[starts-with(., '#')]" mode="resolve-refs">
    <!-- The linked-to element. If the only child of a body, drop fragment identifier -->
    <xsl:param name="element" as="element(*)?"/>
    <xsl:variable name="this-chunk" select="ancestor::html:chunk" as="element(html:chunk)?"/>
    <xsl:variable name="target-chunk" select="key('chunk-by-id', replace(., '^#', ''), $chunks)" as="element(html:chunk)*"/>
    <xsl:if test="count($target-chunk) gt 1">
      <!-- This may happen for example if a div with the id 'frontmatter' is split. We tacitly assume that the first chunk 
        that contains this id is out target chunk. -->
      <!--<xsl:message>!!!!!!!!!!!!!!!!!!!!!!!! Error in source data: More than one element with id <xsl:value-of
          select="replace(., '^#', '')"/>. Only considering the first one. !!!!!!!!!!!!!!!!!!!!!!!!!!</xsl:message>-->
    </xsl:if>
    <xsl:choose>
      <xsl:when test="count($target-chunk) ge 1">
        <xsl:choose>
          <xsl:when test="$this-chunk is $target-chunk[1]">
            <xsl:copy-of select="."/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="new-href" as="xs:string" select="replace($target-chunk[1]/@file, '^.+/', '')"/>
            <xsl:choose>
              <xsl:when test="$element/self::html:body">
                <!-- no fragment identifier if it is the body -->
                <xsl:attribute name="href" select="$new-href"/>
              </xsl:when>
              <xsl:when test="$element is $element/parent::html:body/*[1]">
                <!-- no fragment identifier if it is the first (or only) element -->
                <xsl:attribute name="href" select="$new-href"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="href" select="concat($new-href, .)"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:message>Cannot find target for href=<xsl:value-of select="."/>
        </xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="html:link/@href[matches(., '^(file|https?):')]
                      |html:img/@src[matches(., '^(file|https?):')]
                      |svg:image/@xlink:href[matches(., '^(file|https?):')]
                      |html:video/@src[matches(., '^(file|https?):')]
                      |html:audio/@src[matches(., '^(file|https?):')]
                      |html:source/@src[matches(., '^(file|https?):')]
                      |mml:math/@altimg[matches(., '^(file|https?):')]"
    mode="resolve-refs" priority="2">
    <xsl:variable name="hopefully-relative" as="xs:string" select="replace(., $common-dir-elimination-regex, '')"/>
    <xsl:choose>
      <xsl:when test="matches($hopefully-relative, '^(https?|file)')">
        <!-- radical path removal as a last resort – don’t know whether this pure file name is in the content.opf like this: -->
        <xsl:attribute name="{name()}" select="replace(., '^.+/', if (normalize-space($html-prefix)) then '../' else '')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:attribute name="{name()}" select="concat(if (normalize-space($html-prefix)) then '../' else '', $hopefully-relative)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- relative links -->
  <xsl:template match="html:link/@href[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |html:img/@src[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |svg:image/@xlink:href[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |html:video/@src[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |html:audio/@src[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |html:source/@src[normalize-space($html-prefix)][not(matches(., '^#'))]
                      |mml:math/@altimg[normalize-space($html-prefix)][not(matches(., '^#'))]"
    mode="resolve-refs">
    <xsl:attribute name="{name()}" select="concat('../', .)"/>
  </xsl:template>

  <xsl:template match="@xml:base" mode="resolve-refs"/>

  <!-- should be [not(html:nav[@epub:type = 'toc'])] but people are using other stuff in EPUB2 production -->
  <xsl:template match="html:body[count(*/@epub:type) = 1][*[1]/@epub:type][not(*[@epub:type = 'toc'])]" mode="resolve-refs">
    <!-- If there is only one element with an epub:type, and if it is the first (incl.: only) child
      of body, assume that its epub:type applies to the whole chunk and merge its epub:type with
    the body’s epub:type -->
    <xsl:copy>
      <xsl:apply-templates select="@*" mode="#current"/>
      <xsl:attribute name="epub:type" select="distinct-values((@epub:type, */@epub:type))"/>
      <xsl:apply-templates mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <!-- should be self::html:nav[@epub:type = 'toc'] but people are using other stuff in EPUB2 production -->
  <xsl:template match="html:body[count(*/@epub:type) = 1][*[1]/@epub:type]/*[@epub:type][not(self::*[@epub:type = 'toc'])]" mode="resolve-refs">
    <xsl:copy>
      <xsl:apply-templates select="@* except @epub:type, node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>

  <xsl:function name="tr:abbreviate-for-toc" as="xs:string?">
    <xsl:param name="content" as="xs:string?"/>
    <xsl:variable name="tokenized" as="xs:string*" select="tokenize($content, '[\s\p{Zs}]+')"/>
    <xsl:variable name="normalized" as="xs:string" select="replace(
                                                             string-join(
                                                               $tokenized[position() = (1 to 8)],
                                                               ' '
                                                             ),
                                                             '[\s&#xa0;]*[.,:;\?!–—…]$',
                                                             ''
                                                           )"/>
    <xsl:choose>
      <xsl:when test="count($tokenized) le 8">
        <xsl:sequence select="$normalized"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="concat($normalized, '&#xa0;…')"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <xsl:function name="tr:export-filename" as="xs:string">
    <xsl:param name="split-genid" as="xs:string?"/>
    <xsl:if test="empty($split-genid)">
      <xsl:message terminate="no"> Something’s wrong: should have a generated ID in every chunk </xsl:message>
    </xsl:if>
    <xsl:sequence select="distinct-values(key('by-tr-genid', $split-genid, $output-file-names)/@tr-output-name)"/>
  </xsl:function>

  <xsl:function name="tr:custom-pad" as="xs:string">
    <xsl:param name="generated-id" as="xs:string"/>
    <xsl:param name="final-length" as="xs:integer"/>
    <xsl:sequence select="string-join(
      (for $i in 1 to ($final-length - string-length(replace($generated-id, '^.*?([0-9]+)$', '$1'))) return '0', 
        replace($generated-id, '^.*?([0-9]+)$', '$1')), '')"/>
  </xsl:function>

  <xsl:function name="tr:index-of" as="xs:integer*">
    <xsl:param name="nodes" as="node()*"/>
    <xsl:param name="node" as="node()"/>
    <xsl:sequence select="index-of(for $n in $nodes return generate-id($n), generate-id($node))"/>
  </xsl:function>

  <xsl:function name="tr:contains-token" as="xs:boolean">
    <xsl:param name="string" as="xs:string?"/>
    <xsl:param name="tokens" as="xs:string*"/>
    <xsl:sequence select="if ($string) then tokenize($string, '\s+') = $tokens else false()"/>
  </xsl:function>

</xsl:stylesheet>
